-- Decompiled with CoDLUIDecompiler by JariK

-- OP Count: 0xD1
-- Constant Count: 0x5D
-- Registers Count: 0x11
-- UpValue Count: 0x0
-- SubFuncs Count: 0x31
local registerVal0 = {}
-- r(1) = c[0] // "Up"
-- r(2) = c[1] // "Down"
-- r(3) = c[2] // "Left"
-- r(4) = c[3] // "Right"
-- r(5) = c[4] // "Start"
-- r(6) = c[5] // "Back"
-- r(7) = c[6] // "LeftStick"
-- r(8) = c[7] // "RightStick"
-- r(9) = c[8] // "LeftBumper"
-- r(10) = c[9] // "RightBumper"
-- r(11) = c[10] // "A"
-- r(12) = c[11] // "B"
-- r(13) = c[12] // "X"
-- r(14) = c[13] // "Y"
-- r(15) = c[14] // "LeftTrigger"
-- r(16) = c[15] // "RightTrigger"
registerVal0 = {"Up", "Down", "Left", "Right", "Start", "Back", "LeftStick", "RightStick", "LeftBumper", "RightBumper", "A", "B", "X", "Y", "LeftTrigger", "RightTrigger"}
-- r(1) = g[16] // WorldMap
-- r(2) = g[18] // CreateEnum
-- r(3) = r(0) // registerVal0
local registerVal2 = CreateEnum(registerVal0)
WorldMap.PadButtons = registerVal2
-- r(1) = g[16] // WorldMap
WorldMap.AutomaticCursorSlowUpdateSpeed = 0.066700
-- r(1) = g[16] // WorldMap
WorldMap.MaxDistCursorMove = 140.000000
-- r(1) = g[16] // WorldMap
WorldMap.MaxDistCameraMove = 120.000000
-- r(1) = g[16] // WorldMap
WorldMap.TestDist = 10.000000
-- r(1) = g[16] // WorldMap
WorldMap.XCursorBoundaryMin = 0.300000
-- r(1) = g[16] // WorldMap
WorldMap.XCursorBoundaryMax = 0.700000
-- r(1) = g[16] // WorldMap
WorldMap.YCursorBoundaryMin = 0.300000
-- r(1) = g[16] // WorldMap
WorldMap.YCursorBoundaryMax = 0.700000
-- r(1) = g[16] // WorldMap
WorldMap.ControllerInput = false
-- r(1) = g[16] // WorldMap
WorldMap.KeyboardScrolling = false
-- r(1) = g[16] // WorldMap
-- r(2) = g[37] // CVector3
-- r(3) = c[38] // 0.000000
-- r(4) = c[38] // 0.000000
-- r(5) = c[38] // 0.000000
registerVal2 = CVector3(0.000000, 0.000000, 0.000000)
WorldMap.MouseMove = registerVal2
-- r(1) = g[16] // WorldMap
-- r(2) = g[37] // CVector3
-- r(3) = c[38] // 0.000000
-- r(4) = c[38] // 0.000000
-- r(5) = c[38] // 0.000000
registerVal2 = CVector3(0.000000, 0.000000, 0.000000)
WorldMap.CameraMoveAmount = registerVal2
-- r(1) = g[16] // WorldMap
WorldMap.MouseMultiplier = 1.300000
-- r(1) = g[16] // WorldMap
WorldMap.MovingFamilyLightDistance = -75.000000
-- r(1) = g[16] // WorldMap
	-- OP Count: 0xBE
	-- Constant Count: 0x29
	-- Registers Count: 0xF
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.ProcessGameAction(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
	-- r(8) = g[0] // EWorldMapModes
	-- r(8) = r(8).field(1) // EWorldMapModes.MAP_MODE_ZOOM
	{}[EWorldMapModes.MAP_MODE_ZOOM] = {}
	-- r(8) = g[0] // EWorldMapModes
	-- r(8) = r(8).field(2) // EWorldMapModes.MAP_MODE_QUEST_GIVER
	{}[EWorldMapModes.MAP_MODE_QUEST_GIVER] = {}
	-- r(8) = g[0] // EWorldMapModes
	-- r(8) = r(8).field(3) // EWorldMapModes.MAP_MODE_HOUSE
	{}[EWorldMapModes.MAP_MODE_HOUSE] = {}
	-- r(8) = g[0] // EWorldMapModes
	-- r(8) = r(8).field(4) // EWorldMapModes.MAP_MODE_RULER_BOARD
	{}[EWorldMapModes.MAP_MODE_RULER_BOARD] = {}
	-- r(8) = g[0] // EWorldMapModes
	-- r(8) = r(8).field(5) // EWorldMapModes.MAP_MODE_PARTNERS_GUI
	{}[EWorldMapModes.MAP_MODE_PARTNERS_GUI] = {}
	arg0.ControllerInput = false
	-- r(8) = g[8] // EGameAction
	-- r(8) = r(8).field(9) // EGameAction.GAME_ACTION_WORLD_MAP_CAMERA_MOVEMENT
	if arg1 == EGameAction.GAME_ACTION_WORLD_MAP_CAMERA_MOVEMENT then
		arg0.CursorAndScrollingLinked = true
		arg0.ControllerInput = true
		-- r(8) = r(0):c[12] // arg0:ProcessCursorAndCameraMovement
		-- r(10) = r(1) // arg1
		-- r(11) = g[13] // CVector3
		-- r(12) = r(3) // arg3
		-- r(13) = r(4) // arg4
		-- r(14) = c[14] // 0.000000
		arg0:ProcessCursorAndCameraMovement(arg1, CVector3(arg3, arg4, 0.000000))
		-- skip the next [140] opcodes // advance 140 lines
	else
		-- r(8) = g[8] // EGameAction
		-- r(8) = r(8).field(15) // EGameAction.GAME_ACTION_WORLD_MAP_MOVE_CURSOR
		if arg1 == EGameAction.GAME_ACTION_WORLD_MAP_MOVE_CURSOR then
			-- r(8) = r(0):c[16] // arg0:ShouldIgnoreAnyInput
			local registerVal8 = arg0:ShouldIgnoreAnyInput()
			if not registerVal8 then
				arg0.CursorAndScrollingLinked = false
				-- r(8) = g[13] // CVector3
				-- r(9) = r(3) // arg3
				-- r(10) = r(4) // arg4
				-- r(11) = c[14] // 0.000000
				registerVal8 = CVector3(arg3, arg4, 0.000000)
				arg0.MouseMove = registerVal8
				-- skip the next [124] opcodes // advance 124 lines
			else
				-- r(8) = g[8] // EGameAction
				-- r(8) = r(8).field(18) // EGameAction.GAME_ACTION_CAMERA_ROTATION
				if arg1 == EGameAction.GAME_ACTION_CAMERA_ROTATION then
					-- r(8) = r(0):c[16] // arg0:ShouldIgnoreAnyInput
					registerVal8 = arg0:ShouldIgnoreAnyInput()
					if not registerVal8 then
						arg0.CursorAndScrollingLinked = false
						-- r(8) = g[13] // CVector3
						-- r(9) = r(0).field(19) // arg0.MouseMultiplier
						-- r(10) = r(0).field(17) // arg0.MouseMove
						-- r(10) = r(10):c[20] // arg0.MouseMove:GetY
						local registerVal10 = arg0.MouseMove:GetY()
						-- r(11) = r(0).field(19) // arg0.MouseMultiplier
						-- r(11) = c[14] // 0.000000
						registerVal8 = CVector3((arg3 * arg0.MouseMultiplier), (registerVal10 * arg0.MouseMultiplier), 0.000000)
						arg0.MouseMove = registerVal8
						-- skip the next [103] opcodes // advance 103 lines
					else
						-- r(8) = g[8] // EGameAction
						-- r(8) = r(8).field(21) // EGameAction.GAME_ACTION_CAMERA_ZOOM
						if arg1 == EGameAction.GAME_ACTION_CAMERA_ZOOM then
							-- r(8) = r(0):c[16] // arg0:ShouldIgnoreAnyInput
							registerVal8 = arg0:ShouldIgnoreAnyInput()
							if not registerVal8 then
								arg0.CursorAndScrollingLinked = false
								-- r(8) = g[13] // CVector3
								-- r(9) = r(0).field(17) // arg0.MouseMove
								-- r(9) = r(9):c[22] // arg0.MouseMove:GetX
								local registerVal9 = arg0.MouseMove:GetX()
								-- r(10) = r(4) // arg4
								-- r(11) = c[14] // 0.000000
								registerVal8 = CVector3(registerVal9, arg4, 0.000000)
								arg0.MouseMove = registerVal8
								-- skip the next [85] opcodes // advance 85 lines
							else
								-- r(8) = g[8] // EGameAction
								-- r(8) = r(8).field(23) // EGameAction.GAME_ACTION_WORLD_MAP_SCROLL_MAP
								if arg1 == EGameAction.GAME_ACTION_WORLD_MAP_SCROLL_MAP then
									-- r(8) = r(0):c[16] // arg0:ShouldIgnoreAnyInput
									registerVal8 = arg0:ShouldIgnoreAnyInput()
									if not registerVal8 then
										arg0.CursorAndScrollingLinked = false
										arg0.KeyboardScrolling = true
										-- r(8) = r(0):c[25] // arg0:ProcessScrollMapAction
										-- r(10) = r(3) // arg3
										-- r(11) = r(4) // arg4
										arg0:ProcessScrollMapAction(arg3, arg4)
										-- skip the next [70] opcodes // advance 70 lines
									else
										-- r(8) = g[8] // EGameAction
										-- r(8) = r(8).field(26) // EGameAction.GAME_ACTION_WORLD_MAP_ORBIT_CAMERA
										if arg1 == EGameAction.GAME_ACTION_WORLD_MAP_ORBIT_CAMERA then
											-- r(8) = r(0):c[12] // arg0:ProcessCursorAndCameraMovement
											-- r(10) = r(1) // arg1
											-- r(11) = g[13] // CVector3
											-- r(12) = r(3) // arg3
											-- r(13) = r(4) // arg4
											-- r(14) = c[14] // 0.000000
											arg0:ProcessCursorAndCameraMovement(arg1, CVector3(arg3, arg4, 0.000000))
											-- skip the next [57] opcodes // advance 57 lines
										else
											-- r(8) = g[8] // EGameAction
											-- r(8) = r(8).field(27) // EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT
											-- skip the next [4] opcodes // advance 4 lines
											-- r(8) = g[8] // EGameAction
											-- r(8) = r(8).field(28) // EGameAction.GAME_ACTION_EMOTION_UI_CHOICE_1_PRESSED
											if arg1 == EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT or arg1 == EGameAction.GAME_ACTION_EMOTION_UI_CHOICE_1_PRESSED then
												-- r(8) = r(0):c[29] // arg0:ProcessAcceptAction
												-- r(10) = r(7) // {}
												arg0:ProcessAcceptAction({})
												-- r(8) = g[8] // EGameAction
												-- r(8) = r(8).field(28) // EGameAction.GAME_ACTION_EMOTION_UI_CHOICE_1_PRESSED
												if arg1 == EGameAction.GAME_ACTION_EMOTION_UI_CHOICE_1_PRESSED then
													-- r(8) = g[8] // EGameAction
													-- r(1) = r(8).field(27) // EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT
													-- skip the next [39] opcodes // advance 39 lines
												else
													-- r(8) = g[8] // EGameAction
													-- r(8) = r(8).field(30) // EGameAction.GAME_ACTION_WORLD_MAP_CANCEL
													if EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT == EGameAction.GAME_ACTION_WORLD_MAP_CANCEL then
														-- r(8) = r(0):c[31] // arg0:ProcessCancelAction
														-- r(10) = r(7) // {}
														arg0:ProcessCancelAction({})
														-- skip the next [31] opcodes // advance 31 lines
													else
														-- r(8) = g[8] // EGameAction
														-- r(8) = r(8).field(32) // EGameAction.GAME_ACTION_WORLD_MAP_CONTEXT_SENSITIVE_ACTION_1
														if EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT == EGameAction.GAME_ACTION_WORLD_MAP_CONTEXT_SENSITIVE_ACTION_1 then
															-- r(8) = r(0):c[33] // arg0:ProcessContextSensitiveAction1
															-- r(10) = r(7) // {}
															arg0:ProcessContextSensitiveAction1({})
															-- skip the next [23] opcodes // advance 23 lines
														else
															-- r(8) = g[8] // EGameAction
															-- r(8) = r(8).field(34) // EGameAction.GAME_ACTION_WORLD_MAP_CONTEXT_SENSITIVE_ACTION_2
															if EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT == EGameAction.GAME_ACTION_WORLD_MAP_CONTEXT_SENSITIVE_ACTION_2 then
																-- r(8) = r(0):c[35] // arg0:ProcessContextSensitiveAction2
																-- r(10) = r(7) // {}
																arg0:ProcessContextSensitiveAction2({})
																-- skip the next [15] opcodes // advance 15 lines
															else
																-- r(8) = g[8] // EGameAction
																-- r(8) = r(8).field(36) // EGameAction.GAME_ACTION_WORLD_MAP_MOVE_MAP_ITEM_TOGGLE
																if EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT == EGameAction.GAME_ACTION_WORLD_MAP_MOVE_MAP_ITEM_TOGGLE then
																	-- r(8) = r(0):c[37] // arg0:ProcessMoveMapItemToggle
																	-- r(10) = r(7) // {}
																	arg0:ProcessMoveMapItemToggle({})
																	-- skip the next [7] opcodes // advance 7 lines
																else
																	-- r(8) = g[8] // EGameAction
																	-- r(8) = r(8).field(38) // EGameAction.GAME_ACTION_PAUSE
																	if EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT == EGameAction.GAME_ACTION_PAUSE then
																		-- r(8) = r(0):c[39] // arg0:ProcessPauseAction
																		-- r(10) = r(7) // {}
																		arg0:ProcessPauseAction({})
																	end
																end
															end
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
	-- r(8) = nil
	-- r(9) = r(0).field(40) // arg0.Mode
	-- r(9) = r(7)[r(9)] // {}[arg0.Mode]
	if {}[arg0.Mode] then
		-- r(9) = r(0).field(40) // arg0.Mode
		-- r(9) = r(7)[r(9)] // {}[arg0.Mode]
		-- r(8) = r(9)[r(1)] // {}[arg0.Mode][EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT]
	end
	if {}[arg0.Mode][EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT] then
		-- r(9) = r(8) // {}[arg0.Mode][EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT]
		{}[arg0.Mode][EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT]()
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x20
	-- Constant Count: 0xE
	-- Registers Count: 0x5
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x1
function WorldMap.ProcessPauseAction(arg0, arg1)
	-- r(2) = r(0).field(0) // arg0.State
	-- r(3) = g[1] // EWorldMapState
	-- r(3) = r(3).field(2) // EWorldMapState.MAP_STATE_WEDDING_LOCATION
	-- skip the next [26] opcodes // advance 26 lines
	-- r(2) = r(0).field(0) // arg0.State
	-- r(3) = g[1] // EWorldMapState
	-- r(3) = r(3).field(3) // EWorldMapState.MAP_STATE_SPECTATOR_MODE
	-- skip the next [21] opcodes // advance 21 lines
	-- r(2) = r(0).field(0) // arg0.State
	-- r(3) = g[1] // EWorldMapState
	-- r(3) = r(3).field(4) // EWorldMapState.MAP_STATE_SPECTATOR_MODE_WEDDING_LOCATION
	-- skip the next [16] opcodes // advance 16 lines
	-- r(2) = g[5] // WorldMapAbility
	-- r(2) = r(2).field(6) // WorldMapAbility.IsMapAbilityAvailable
	-- r(3) = g[7] // EWorldMapAbility
	-- r(3) = r(3).field(8) // EWorldMapAbility.MAP_ABILITY_BACKOUT_WORLD_MAP
	-- r(4) = r(0).field(9) // arg0.PlayerEntity
	local registerVal2 = WorldMapAbility.IsMapAbilityAvailable(EWorldMapAbility.MAP_ABILITY_BACKOUT_WORLD_MAP, arg0.PlayerEntity)
	if arg0.State ~= EWorldMapState.MAP_STATE_WEDDING_LOCATION and arg0.State ~= EWorldMapState.MAP_STATE_SPECTATOR_MODE and arg0.State ~= EWorldMapState.MAP_STATE_SPECTATOR_MODE_WEDDING_LOCATION and registerVal2 then
		-- r(2) = g[10] // EWorldMapModes
		-- r(2) = r(2).field(11) // EWorldMapModes.MAP_MODE_ZOOM
		-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
		-- r(3) = g[12] // EGameAction
		-- r(3) = r(3).field(13) // EGameAction.GAME_ACTION_PAUSE
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
		local function __FUNC_192D_()
			-- r(0) = r(0):c[0] // :ExitToGame
			:ExitToGame()
			-- return
		end

		-- r(0) = r(0) // arg0
		arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_PAUSE] = __FUNC_192D_
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0xC4
	-- Constant Count: 0x28
	-- Registers Count: 0x6
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x7
function WorldMap.ProcessAcceptAction(arg0, arg1)
	-- r(2) = r(0):c[0] // arg0:ShouldIgnoreButtonInput
	local registerVal2 = arg0:ShouldIgnoreButtonInput()
	if registerVal2 then
		return 
	end
	-- r(2) = r(0).field(1) // arg0.State
	-- r(3) = g[2] // EWorldMapState
	-- r(3) = r(3).field(3) // EWorldMapState.MAP_STATE_TAX
	if arg0.State == EWorldMapState.MAP_STATE_TAX then
		-- r(2) = r(0):c[4] // arg0:GetView
		registerVal2 = arg0:GetView()
		-- r(3) = g[5] // EWorldMapView
		-- r(3) = r(3).field(6) // EWorldMapView.MAP_VIEW_WORLD
		if registerVal2 == EWorldMapView.MAP_VIEW_WORLD then
			-- r(2) = g[7] // EWorldMapModes
			-- r(2) = r(2).field(8) // EWorldMapModes.MAP_MODE_RULER_BOARD
			-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_RULER_BOARD]
			-- r(3) = g[9] // EGameAction
			-- r(3) = r(3).field(10) // EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
			local function __FUNC_21F8_()
				-- r(0) = r(0):c[0] // :ExitRulerMode
				:ExitRulerMode()
				-- return
			end

			-- r(0) = r(0) // arg0
			arg1[EWorldMapModes.MAP_MODE_RULER_BOARD][EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT] = __FUNC_21F8_
			-- skip the next [157] opcodes // advance 157 lines
		else
			-- r(2) = r(0).field(1) // arg0.State
			-- r(3) = g[2] // EWorldMapState
			-- r(3) = r(3).field(11) // EWorldMapState.MAP_STATE_MOVING_FAMILY
			if arg0.State == EWorldMapState.MAP_STATE_MOVING_FAMILY then
				-- r(2) = r(0):c[4] // arg0:GetView
				registerVal2 = arg0:GetView()
				-- r(3) = g[5] // EWorldMapView
				-- r(3) = r(3).field(6) // EWorldMapView.MAP_VIEW_WORLD
				if registerVal2 == EWorldMapView.MAP_VIEW_WORLD then
					-- r(2) = g[7] // EWorldMapModes
					-- r(2) = r(2).field(12) // EWorldMapModes.MAP_MODE_ZOOM
					-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
					-- r(3) = g[9] // EGameAction
					-- r(3) = r(3).field(10) // EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
					local function __FUNC_22B4_()
						-- r(0) = r(0):c[0] // :ZoomIn
						:ZoomIn()
						-- return
					end

					-- r(0) = r(0) // arg0
					arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT] = __FUNC_22B4_
					-- skip the next [137] opcodes // advance 137 lines
				else
					-- r(2) = r(0).field(1) // arg0.State
					-- r(3) = g[2] // EWorldMapState
					-- r(3) = r(3).field(13) // EWorldMapState.MAP_STATE_WEDDING_LOCATION
					-- skip the next [10] opcodes // advance 10 lines
					-- r(2) = r(0).field(1) // arg0.State
					-- r(3) = g[2] // EWorldMapState
					-- r(3) = r(3).field(14) // EWorldMapState.MAP_STATE_SPECTATOR_MODE
					-- skip the next [5] opcodes // advance 5 lines
					-- r(2) = r(0).field(1) // arg0.State
					-- r(3) = g[2] // EWorldMapState
					-- r(3) = r(3).field(15) // EWorldMapState.MAP_STATE_SPECTATOR_MODE_WEDDING_LOCATION
					if arg0.State ~= EWorldMapState.MAP_STATE_WEDDING_LOCATION and arg0.State == EWorldMapState.MAP_STATE_SPECTATOR_MODE or arg0.State == EWorldMapState.MAP_STATE_SPECTATOR_MODE_WEDDING_LOCATION then
						-- r(2) = g[7] // EWorldMapModes
						-- r(2) = r(2).field(12) // EWorldMapModes.MAP_MODE_ZOOM
						-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
						-- r(3) = g[9] // EGameAction
						-- r(3) = r(3).field(10) // EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
						local function __FUNC_2369_()
							-- r(0) = r(0):c[0] // :DoNothing
							:DoNothing()
							-- return
						end

						-- r(0) = r(0) // arg0
						arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT] = __FUNC_2369_
						-- skip the next [113] opcodes // advance 113 lines
					else
						-- r(2) = r(0).field(1) // arg0.State
						-- r(3) = g[2] // EWorldMapState
						-- r(3) = r(3).field(16) // EWorldMapState.MAP_STATE_QUEST_SUMMARY
						if arg0.State == EWorldMapState.MAP_STATE_QUEST_SUMMARY then
							-- r(2) = g[7] // EWorldMapModes
							-- r(2) = r(2).field(12) // EWorldMapModes.MAP_MODE_ZOOM
							-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
							-- r(3) = g[9] // EGameAction
							-- r(3) = r(3).field(10) // EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT
		-- OP Count: 0x9
		-- Constant Count: 0x4
		-- Registers Count: 0x3
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
							local function __FUNC_2421_()
								-- r(0) = r(0):c[0] // :PreConditionalTeleport
								-- r(2) = true
								:PreConditionalTeleport(true)
								-- r(1) = g[2] // EWorldMapState
								-- r(1) = r(1).field(3) // EWorldMapState.MAP_STATE_DEFAULT
								:PreConditionalTeleport.State = EWorldMapState.MAP_STATE_DEFAULT
								-- return
							end

							-- r(0) = r(0) // arg0
							arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT] = __FUNC_2421_
							-- skip the next [99] opcodes // advance 99 lines
						else
							-- r(2) = false
							-- r(3) = r(0).field(17) // arg0.Target
							if arg0.Target then
								-- r(3) = r(0).field(17) // arg0.Target
								-- r(3) = r(3).field(18) // arg0.Target.Type
								-- r(4) = g[19] // EWorldMapEntityType
								-- r(4) = r(4).field(20) // EWorldMapEntityType.MAP_ENTITY_QUEST_GIVER_CHARACTER
								-- skip the next [6] opcodes // advance 6 lines
								-- r(3) = r(0).field(17) // arg0.Target
								-- r(3) = r(3).field(18) // arg0.Target.Type
								-- r(4) = g[19] // EWorldMapEntityType
								-- r(4) = r(4).field(21) // EWorldMapEntityType.MAP_ENTITY_QUEST_GIVER_OBJECT
								if arg0.Target.Type == EWorldMapEntityType.MAP_ENTITY_QUEST_GIVER_CHARACTER or arg0.Target.Type == EWorldMapEntityType.MAP_ENTITY_QUEST_GIVER_OBJECT then
									-- r(3) = g[22] // WorldMapAbility
									-- r(3) = r(3).field(23) // WorldMapAbility.IsMapAbilityAvailable
									-- r(4) = g[24] // EWorldMapAbility
									-- r(4) = r(4).field(25) // EWorldMapAbility.MAP_ABILITY_ZOOM_TO_QUEST_GIVER
									-- r(5) = r(0).field(26) // arg0.PlayerEntity
									local registerVal3 = WorldMapAbility.IsMapAbilityAvailable(EWorldMapAbility.MAP_ABILITY_ZOOM_TO_QUEST_GIVER, arg0.PlayerEntity)
									if registerVal3 then
										-- r(2) = true
										-- skip the next [44] opcodes // advance 44 lines
									else
										-- r(3) = r(0).field(17) // arg0.Target
										-- r(3) = r(3).field(18) // arg0.Target.Type
										-- r(4) = g[19] // EWorldMapEntityType
										-- r(4) = r(4).field(27) // EWorldMapEntityType.MAP_ENTITY_BUILDING
										if arg0.Target.Type == EWorldMapEntityType.MAP_ENTITY_BUILDING then
											-- r(3) = g[22] // WorldMapAbility
											-- r(3) = r(3).field(23) // WorldMapAbility.IsMapAbilityAvailable
											-- r(4) = g[24] // EWorldMapAbility
											-- r(4) = r(4).field(28) // EWorldMapAbility.MAP_ABILITY_ZOOM_TO_HOUSE
											-- r(5) = r(0).field(26) // arg0.PlayerEntity
											registerVal3 = WorldMapAbility.IsMapAbilityAvailable(EWorldMapAbility.MAP_ABILITY_ZOOM_TO_HOUSE, arg0.PlayerEntity)
											-- skip the next [30] opcodes // advance 30 lines
											-- r(3) = g[29] // PlayerProperties
											-- r(3) = r(3).field(30) // PlayerProperties.GetIsBuyable
											-- r(4) = g[31] // GetGameOwningHeroFromGameWorld
											local registerVal4 = GetGameOwningHeroFromGameWorld()
											-- r(5) = r(0).field(17) // arg0.Target
											-- r(5) = r(5).field(32) // arg0.Target.EntityID
											registerVal3 = PlayerProperties.GetIsBuyable(registerVal4, arg0.Target.EntityID)
											-- skip the next [21] opcodes // advance 21 lines
											-- r(2) = true
											-- skip the next [19] opcodes // advance 19 lines
											-- r(3) = g[22] // WorldMapAbility
											-- r(3) = r(3).field(23) // WorldMapAbility.IsMapAbilityAvailable
											-- r(4) = g[24] // EWorldMapAbility
											-- r(4) = r(4).field(33) // EWorldMapAbility.MAP_ABILITY_ZOOM_TO_REGION
											-- r(5) = r(0).field(26) // arg0.PlayerEntity
											registerVal3 = WorldMapAbility.IsMapAbilityAvailable(EWorldMapAbility.MAP_ABILITY_ZOOM_TO_REGION, arg0.PlayerEntity)
											-- skip the next [11] opcodes // advance 11 lines
											-- r(2) = true
											-- skip the next [9] opcodes // advance 9 lines
											-- r(3) = g[22] // WorldMapAbility
											-- r(3) = r(3).field(23) // WorldMapAbility.IsMapAbilityAvailable
											-- r(4) = g[24] // EWorldMapAbility
											-- r(4) = r(4).field(33) // EWorldMapAbility.MAP_ABILITY_ZOOM_TO_REGION
											-- r(5) = r(0).field(26) // arg0.PlayerEntity
											registerVal3 = WorldMapAbility.IsMapAbilityAvailable(EWorldMapAbility.MAP_ABILITY_ZOOM_TO_REGION, arg0.PlayerEntity)
											if registerVal3 and registerVal3 and registerVal3 and registerVal3 then
												-- r(2) = true
											end
										end
									end
								end
							end
							if true then
								-- r(3) = r(0):c[34] // arg0:GetState
								registerVal3 = arg0:GetState()
								-- r(4) = g[2] // EWorldMapState
								-- r(4) = r(4).field(35) // EWorldMapState.MAP_STATE_VIEW_ORB
								if registerVal3 == EWorldMapState.MAP_STATE_VIEW_ORB then
									-- r(3) = r(0):c[36] // arg0:CanJoinGameViaOrb
									registerVal3 = arg0:CanJoinGameViaOrb()
									if registerVal3 then
										-- r(3) = g[7] // EWorldMapModes
										-- r(3) = r(3).field(12) // EWorldMapModes.MAP_MODE_ZOOM
										-- r(3) = r(1)[r(3)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
										-- r(4) = g[9] // EGameAction
										-- r(4) = r(4).field(10) // EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
										local function __FUNC_2544_()
											-- r(0) = r(0):c[0] // :ConditionalJoinGameViaOrb
											:ConditionalJoinGameViaOrb()
											-- return
										end

										-- r(0) = r(0) // arg0
										arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT] = __FUNC_2544_
										-- skip the next [8] opcodes // advance 8 lines
									else
										-- r(3) = g[7] // EWorldMapModes
										-- r(3) = r(3).field(12) // EWorldMapModes.MAP_MODE_ZOOM
										-- r(3) = r(1)[r(3)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
										-- r(4) = g[9] // EGameAction
										-- r(4) = r(4).field(10) // EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
										local function __FUNC_260C_()
											-- r(0) = r(0):c[0] // :ZoomIn
											:ZoomIn()
											-- return
										end

										-- r(0) = r(0) // arg0
										arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT] = __FUNC_260C_
									end
								end
							end
						end
					end
				end
			end
		end
	end
	-- r(2) = g[37] // Network
	-- r(2) = r(2).field(38) // Network.IsServer
	registerVal2 = Network.IsServer()
	if registerVal2 then
		-- r(2) = g[7] // EWorldMapModes
		-- r(2) = r(2).field(39) // EWorldMapModes.MAP_MODE_QUEST_GIVER
		-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_QUEST_GIVER]
		-- r(3) = g[9] // EGameAction
		-- r(3) = r(3).field(10) // EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT
		-- OP Count: 0x5
		-- Constant Count: 0x1
		-- Registers Count: 0x3
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
		local function __FUNC_26C1_()
			-- r(0) = r(0):c[0] // :PreConditionalTeleport
			-- r(2) = true
			:PreConditionalTeleport(true)
			-- return
		end

		-- r(0) = r(0) // arg0
		arg1[EWorldMapModes.MAP_MODE_QUEST_GIVER][EGameAction.GAME_ACTION_WORLD_MAP_ACCEPT] = __FUNC_26C1_
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x97
	-- Constant Count: 0x1F
	-- Registers Count: 0x8
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x7
function WorldMap.ProcessCancelAction(arg0, arg1)
	-- r(2) = r(0):c[0] // arg0:ShouldIgnoreButtonInput
	local registerVal2 = arg0:ShouldIgnoreButtonInput()
	if registerVal2 then
		return 
	end
	-- r(2) = r(0).field(1) // arg0.State
	-- r(3) = g[2] // EWorldMapState
	-- r(3) = r(3).field(3) // EWorldMapState.MAP_STATE_QUEST_SUMMARY
	if arg0.State == EWorldMapState.MAP_STATE_QUEST_SUMMARY then
		-- r(2) = g[4] // EWorldMapModes
		-- r(2) = r(2).field(5) // EWorldMapModes.MAP_MODE_ZOOM
		-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
		-- r(3) = g[6] // EGameAction
		-- r(3) = r(3).field(7) // EGameAction.GAME_ACTION_WORLD_MAP_CANCEL
		-- OP Count: 0x7
		-- Constant Count: 0x5
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
		local function __FUNC_30DC_()
			-- r(1) = g[1] // EWorldMapState
			-- r(1) = r(1).field(2) // EWorldMapState.MAP_STATE_DEFAULT
			.State = EWorldMapState.MAP_STATE_DEFAULT
			.QuestID = nil
			-- return
		end

		-- r(0) = r(0) // arg0
		arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_CANCEL] = __FUNC_30DC_
		-- skip the next [58] opcodes // advance 58 lines
	else
		-- r(2) = g[8] // WorldMapAbility
		-- r(2) = r(2).field(9) // WorldMapAbility.IsMapAbilityAvailable
		-- r(3) = g[10] // EWorldMapAbility
		-- r(3) = r(3).field(11) // EWorldMapAbility.MAP_ABILITY_BACKOUT_WORLD_MAP
		-- r(4) = r(0).field(12) // arg0.PlayerEntity
		registerVal2 = WorldMapAbility.IsMapAbilityAvailable(EWorldMapAbility.MAP_ABILITY_BACKOUT_WORLD_MAP, arg0.PlayerEntity)
		if registerVal2 then
			-- r(2) = false
			-- r(3) = r(0):c[13] // arg0:GetView
			local registerVal3 = arg0:GetView()
			-- r(4) = g[14] // EWorldMapView
			-- r(4) = r(4).field(15) // EWorldMapView.MAP_VIEW_REGION
			-- skip the next [28] opcodes // advance 28 lines
			-- r(3) = r(0).field(16) // arg0.CurrentRegion
			-- skip the next [25] opcodes // advance 25 lines
			-- r(3) = r(0).field(16) // arg0.CurrentRegion
			-- r(3) = r(3).field(17) // arg0.CurrentRegion.GameLevel
			-- skip the next [21] opcodes // advance 21 lines
			-- r(3) = r(0).field(16) // arg0.CurrentRegion
			-- r(3) = r(3).field(18) // arg0.CurrentRegion.GameWorld
			-- skip the next [17] opcodes // advance 17 lines
			-- r(3) = g[19] // PlayerProperties
			-- r(3) = r(3).field(20) // PlayerProperties.GetNumberOfNonFamilyHouses
			-- r(4) = g[21] // GetGameOwningHeroFromGameWorld
			registerVal3 = PlayerProperties.GetNumberOfNonFamilyHouses(GetGameOwningHeroFromGameWorld())
			-- r(4) = g[19] // PlayerProperties
			-- r(4) = r(4).field(22) // PlayerProperties.GetNumberOfNonFamilyHousesInLevel
			-- r(5) = g[21] // GetGameOwningHeroFromGameWorld
			local registerVal5 = GetGameOwningHeroFromGameWorld()
			-- r(6) = r(0).field(16) // arg0.CurrentRegion
			-- r(6) = r(6).field(18) // arg0.CurrentRegion.GameWorld
			-- r(7) = r(0).field(16) // arg0.CurrentRegion
			-- r(7) = r(7).field(17) // arg0.CurrentRegion.GameLevel
			local registerVal4 = PlayerProperties.GetNumberOfNonFamilyHousesInLevel(registerVal5, arg0.CurrentRegion.GameWorld, arg0.CurrentRegion.GameLevel)
			if registerVal3 == EWorldMapView.MAP_VIEW_REGION and arg0.CurrentRegion and arg0.CurrentRegion.GameLevel and arg0.CurrentRegion.GameWorld and registerVal3 ~= registerVal4 then
				-- r(2) = true
			end
			-- r(3) = r(0).field(1) // arg0.State
			-- r(4) = g[2] // EWorldMapState
			-- r(4) = r(4).field(23) // EWorldMapState.MAP_STATE_MOVING_FAMILY
			-- skip the next [2] opcodes // advance 2 lines
			if arg0.State ~= EWorldMapState.MAP_STATE_MOVING_FAMILY or true then
				-- r(3) = g[4] // EWorldMapModes
				-- r(3) = r(3).field(5) // EWorldMapModes.MAP_MODE_ZOOM
				-- r(3) = r(1)[r(3)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
				-- r(4) = g[6] // EGameAction
				-- r(4) = r(4).field(7) // EGameAction.GAME_ACTION_WORLD_MAP_CANCEL
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
				local function __FUNC_31E1_()
					-- r(0) = r(0):c[0] // :ZoomOut
					:ZoomOut()
					-- return
				end

				-- r(0) = r(0) // arg0
				arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_CANCEL] = __FUNC_31E1_
			end
		end
	end
	-- r(2) = r(0).field(1) // arg0.State
	-- r(3) = g[2] // EWorldMapState
	-- r(3) = r(3).field(24) // EWorldMapState.MAP_STATE_WEDDING_LOCATION
	-- skip the next [10] opcodes // advance 10 lines
	-- r(2) = r(0).field(1) // arg0.State
	-- r(3) = g[2] // EWorldMapState
	-- r(3) = r(3).field(25) // EWorldMapState.MAP_STATE_SPECTATOR_MODE
	-- skip the next [5] opcodes // advance 5 lines
	-- r(2) = r(0).field(1) // arg0.State
	-- r(3) = g[2] // EWorldMapState
	-- r(3) = r(3).field(26) // EWorldMapState.MAP_STATE_SPECTATOR_MODE_WEDDING_LOCATION
	if arg0.State ~= EWorldMapState.MAP_STATE_WEDDING_LOCATION and arg0.State == EWorldMapState.MAP_STATE_SPECTATOR_MODE or arg0.State == EWorldMapState.MAP_STATE_SPECTATOR_MODE_WEDDING_LOCATION then
		-- r(2) = g[4] // EWorldMapModes
		-- r(2) = r(2).field(5) // EWorldMapModes.MAP_MODE_ZOOM
		-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
		-- r(3) = g[6] // EGameAction
		-- r(3) = r(3).field(7) // EGameAction.GAME_ACTION_WORLD_MAP_CANCEL
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
		local function __FUNC_3297_()
			-- r(0) = r(0):c[0] // :DoNothing
			:DoNothing()
			-- return
		end

		-- r(0) = r(0) // arg0
		arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_CANCEL] = __FUNC_3297_
	end
	-- r(2) = g[4] // EWorldMapModes
	-- r(2) = r(2).field(27) // EWorldMapModes.MAP_MODE_QUEST_GIVER
	-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_QUEST_GIVER]
	-- r(3) = g[6] // EGameAction
	-- r(3) = r(3).field(7) // EGameAction.GAME_ACTION_WORLD_MAP_CANCEL
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
	local function __FUNC_334F_()
		-- r(0) = r(0):c[0] // :ZoomOut
		:ZoomOut()
		-- return
	end

	-- r(0) = r(0) // arg0
	arg1[EWorldMapModes.MAP_MODE_QUEST_GIVER][EGameAction.GAME_ACTION_WORLD_MAP_CANCEL] = __FUNC_334F_
	-- r(2) = r(0).field(1) // arg0.State
	-- r(3) = g[2] // EWorldMapState
	-- r(3) = r(3).field(24) // EWorldMapState.MAP_STATE_WEDDING_LOCATION
	-- skip the next [37] opcodes // advance 37 lines
	-- r(2) = r(0).field(1) // arg0.State
	-- r(3) = g[2] // EWorldMapState
	-- r(3) = r(3).field(25) // EWorldMapState.MAP_STATE_SPECTATOR_MODE
	-- skip the next [32] opcodes // advance 32 lines
	-- r(2) = r(0).field(1) // arg0.State
	-- r(3) = g[2] // EWorldMapState
	-- r(3) = r(3).field(26) // EWorldMapState.MAP_STATE_SPECTATOR_MODE_WEDDING_LOCATION
	if arg0.State ~= EWorldMapState.MAP_STATE_WEDDING_LOCATION and arg0.State ~= EWorldMapState.MAP_STATE_SPECTATOR_MODE and arg0.State ~= EWorldMapState.MAP_STATE_SPECTATOR_MODE_WEDDING_LOCATION then
		-- r(2) = g[4] // EWorldMapModes
		-- r(2) = r(2).field(28) // EWorldMapModes.MAP_MODE_HOUSE
		registerVal3 = {}
		-- r(4) = g[6] // EGameAction
		-- r(4) = r(4).field(7) // EGameAction.GAME_ACTION_WORLD_MAP_CANCEL
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
		local function __FUNC_3405_()
			-- r(0) = r(0):c[0] // :ZoomOut
			:ZoomOut()
			-- return
		end

		-- r(0) = r(0) // arg0
		registerVal3[EGameAction.GAME_ACTION_WORLD_MAP_CANCEL] = __FUNC_3405_
		arg1[EWorldMapModes.MAP_MODE_HOUSE] = registerVal3
		-- r(2) = g[4] // EWorldMapModes
		-- r(2) = r(2).field(29) // EWorldMapModes.MAP_MODE_RULER_BOARD
		registerVal3 = {}
		-- r(4) = g[6] // EGameAction
		-- r(4) = r(4).field(7) // EGameAction.GAME_ACTION_WORLD_MAP_CANCEL
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
		local function __FUNC_34BB_()
			-- r(0) = r(0):c[0] // :ExitRulerMode
			:ExitRulerMode()
			-- return
		end

		-- r(0) = r(0) // arg0
		registerVal3[EGameAction.GAME_ACTION_WORLD_MAP_CANCEL] = __FUNC_34BB_
		arg1[EWorldMapModes.MAP_MODE_RULER_BOARD] = registerVal3
		-- r(2) = g[4] // EWorldMapModes
		-- r(2) = r(2).field(30) // EWorldMapModes.MAP_MODE_PARTNERS_GUI
		registerVal3 = {}
		-- r(4) = g[6] // EGameAction
		-- r(4) = r(4).field(7) // EGameAction.GAME_ACTION_WORLD_MAP_CANCEL
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
		local function __FUNC_3577_()
			-- r(0) = r(0):c[0] // :ExitPartnersList
			:ExitPartnersList()
			-- return
		end

		-- r(0) = r(0) // arg0
		registerVal3[EGameAction.GAME_ACTION_WORLD_MAP_CANCEL] = __FUNC_3577_
		arg1[EWorldMapModes.MAP_MODE_PARTNERS_GUI] = registerVal3
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x59
	-- Constant Count: 0x16
	-- Registers Count: 0x5
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x3
function WorldMap.ProcessContextSensitiveAction1(arg0, arg1)
	-- r(2) = r(0):c[0] // arg0:ShouldIgnoreButtonInput
	local registerVal2 = arg0:ShouldIgnoreButtonInput()
	if registerVal2 then
		return 
	end
	-- r(2) = r(0).field(1) // arg0.SelectionMode
	-- skip the next [15] opcodes // advance 15 lines
	-- r(2) = r(0).field(2) // arg0.State
	-- r(3) = g[3] // EWorldMapState
	-- r(3) = r(3).field(4) // EWorldMapState.MAP_STATE_WEDDING_LOCATION
	-- skip the next [10] opcodes // advance 10 lines
	-- r(2) = r(0).field(2) // arg0.State
	-- r(3) = g[3] // EWorldMapState
	-- r(3) = r(3).field(5) // EWorldMapState.MAP_STATE_SPECTATOR_MODE
	-- skip the next [5] opcodes // advance 5 lines
	-- r(2) = r(0).field(2) // arg0.State
	-- r(3) = g[3] // EWorldMapState
	-- r(3) = r(3).field(6) // EWorldMapState.MAP_STATE_SPECTATOR_MODE_WEDDING_LOCATION
	if not arg0.SelectionMode and arg0.State ~= EWorldMapState.MAP_STATE_WEDDING_LOCATION and arg0.State == EWorldMapState.MAP_STATE_SPECTATOR_MODE or arg0.State == EWorldMapState.MAP_STATE_SPECTATOR_MODE_WEDDING_LOCATION then
		-- r(2) = g[7] // EWorldMapModes
		-- r(2) = r(2).field(8) // EWorldMapModes.MAP_MODE_ZOOM
		-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
		-- r(3) = g[9] // EGameAction
		-- r(3) = r(3).field(10) // EGameAction.GAME_ACTION_WORLD_MAP_CONTEXT_SENSITIVE_ACTION_1
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
		local function __FUNC_3D00_()
			-- r(0) = r(0):c[0] // :DoNothing
			:DoNothing()
			-- return
		end

		-- r(0) = r(0) // arg0
		arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_CONTEXT_SENSITIVE_ACTION_1] = __FUNC_3D00_
		-- skip the next [56] opcodes // advance 56 lines
	else
		-- r(2) = r(0):c[11] // arg0:GetView
		registerVal2 = arg0:GetView()
		-- r(3) = g[12] // EWorldMapView
		-- r(3) = r(3).field(13) // EWorldMapView.MAP_VIEW_REGION
		-- skip the next [22] opcodes // advance 22 lines
		-- r(2) = r(0):c[14] // arg0:GetState
		registerVal2 = arg0:GetState()
		-- r(3) = g[3] // EWorldMapState
		-- r(3) = r(3).field(15) // EWorldMapState.MAP_STATE_DEFAULT
		-- skip the next [16] opcodes // advance 16 lines
		-- r(2) = g[16] // WorldMapAbility
		-- r(2) = r(2).field(17) // WorldMapAbility.IsMapAbilityAvailable
		-- r(3) = g[18] // EWorldMapAbility
		-- r(3) = r(3).field(19) // EWorldMapAbility.MAP_ABILITY_QUEST_LIST
		-- r(4) = r(0).field(20) // arg0.PlayerEntity
		registerVal2 = WorldMapAbility.IsMapAbilityAvailable(EWorldMapAbility.MAP_ABILITY_QUEST_LIST, arg0.PlayerEntity)
		if registerVal2 == EWorldMapView.MAP_VIEW_REGION and registerVal2 == EWorldMapState.MAP_STATE_DEFAULT and registerVal2 then
			-- r(2) = g[7] // EWorldMapModes
			-- r(2) = r(2).field(8) // EWorldMapModes.MAP_MODE_ZOOM
			-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
			-- r(3) = g[9] // EGameAction
			-- r(3) = r(3).field(10) // EGameAction.GAME_ACTION_WORLD_MAP_CONTEXT_SENSITIVE_ACTION_1
		-- OP Count: 0x6
		-- Constant Count: 0x3
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
			local function __FUNC_3DB8_()
				-- r(0) = g[0] // GUI
				-- r(0) = r(0).field(1) // GUI.ShowQuestsSummary
				-- r(1) = r(1).field(2) // .PlayerEntity
				GUI.ShowQuestsSummary(.PlayerEntity)
				-- return
			end

			-- r(0) = r(0) // arg0
			arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_CONTEXT_SENSITIVE_ACTION_1] = __FUNC_3DB8_
		end
		-- r(2) = r(0):c[11] // arg0:GetView
		registerVal2 = arg0:GetView()
		-- r(3) = g[12] // EWorldMapView
		-- r(3) = r(3).field(21) // EWorldMapView.MAP_VIEW_WORLD
		-- skip the next [22] opcodes // advance 22 lines
		-- r(2) = r(0):c[14] // arg0:GetState
		registerVal2 = arg0:GetState()
		-- r(3) = g[3] // EWorldMapState
		-- r(3) = r(3).field(15) // EWorldMapState.MAP_STATE_DEFAULT
		-- skip the next [16] opcodes // advance 16 lines
		-- r(2) = g[16] // WorldMapAbility
		-- r(2) = r(2).field(17) // WorldMapAbility.IsMapAbilityAvailable
		-- r(3) = g[18] // EWorldMapAbility
		-- r(3) = r(3).field(19) // EWorldMapAbility.MAP_ABILITY_QUEST_LIST
		-- r(4) = r(0).field(20) // arg0.PlayerEntity
		registerVal2 = WorldMapAbility.IsMapAbilityAvailable(EWorldMapAbility.MAP_ABILITY_QUEST_LIST, arg0.PlayerEntity)
		if registerVal2 == EWorldMapView.MAP_VIEW_WORLD and registerVal2 == EWorldMapState.MAP_STATE_DEFAULT and registerVal2 then
			-- r(2) = g[7] // EWorldMapModes
			-- r(2) = r(2).field(8) // EWorldMapModes.MAP_MODE_ZOOM
			-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
			-- r(3) = g[9] // EGameAction
			-- r(3) = r(3).field(10) // EGameAction.GAME_ACTION_WORLD_MAP_CONTEXT_SENSITIVE_ACTION_1
		-- OP Count: 0x6
		-- Constant Count: 0x3
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
			local function __FUNC_3EA3_()
				-- r(0) = g[0] // GUI
				-- r(0) = r(0).field(1) // GUI.ShowQuestsSummary
				-- r(1) = r(1).field(2) // .PlayerEntity
				GUI.ShowQuestsSummary(.PlayerEntity)
				-- return
			end

			-- r(0) = r(0) // arg0
			arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_CONTEXT_SENSITIVE_ACTION_1] = __FUNC_3EA3_
		end
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x3F
	-- Constant Count: 0x15
	-- Registers Count: 0x5
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x2
function WorldMap.ProcessContextSensitiveAction2(arg0, arg1)
	-- r(2) = r(0):c[0] // arg0:ShouldIgnoreButtonInput
	local registerVal2 = arg0:ShouldIgnoreButtonInput()
	if registerVal2 then
		return 
	end
	-- r(2) = r(0).field(1) // arg0.State
	-- r(3) = g[2] // EWorldMapState
	-- r(3) = r(3).field(3) // EWorldMapState.MAP_STATE_WEDDING_LOCATION
	-- skip the next [10] opcodes // advance 10 lines
	-- r(2) = r(0).field(1) // arg0.State
	-- r(3) = g[2] // EWorldMapState
	-- r(3) = r(3).field(4) // EWorldMapState.MAP_STATE_SPECTATOR_MODE
	-- skip the next [5] opcodes // advance 5 lines
	-- r(2) = r(0).field(1) // arg0.State
	-- r(3) = g[2] // EWorldMapState
	-- r(3) = r(3).field(5) // EWorldMapState.MAP_STATE_SPECTATOR_MODE_WEDDING_LOCATION
	if arg0.State ~= EWorldMapState.MAP_STATE_WEDDING_LOCATION and arg0.State == EWorldMapState.MAP_STATE_SPECTATOR_MODE or arg0.State == EWorldMapState.MAP_STATE_SPECTATOR_MODE_WEDDING_LOCATION then
		-- r(2) = g[6] // EWorldMapModes
		-- r(2) = r(2).field(7) // EWorldMapModes.MAP_MODE_ZOOM
		-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
		-- r(3) = g[8] // EGameAction
		-- r(3) = r(3).field(9) // EGameAction.GAME_ACTION_WORLD_MAP_CONTEXT_SENSITIVE_ACTION_2
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
		local function __FUNC_44C8_()
			-- r(0) = r(0):c[0] // :DoNothing
			:DoNothing()
			-- return
		end

		-- r(0) = r(0) // arg0
		arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_CONTEXT_SENSITIVE_ACTION_2] = __FUNC_44C8_
		-- skip the next [33] opcodes // advance 33 lines
	else
		-- r(2) = r(0):c[10] // arg0:GetView
		registerVal2 = arg0:GetView()
		-- r(3) = g[11] // EWorldMapView
		-- r(3) = r(3).field(12) // EWorldMapView.MAP_VIEW_REGION
		-- skip the next [6] opcodes // advance 6 lines
		-- r(2) = r(0):c[10] // arg0:GetView
		registerVal2 = arg0:GetView()
		-- r(3) = g[11] // EWorldMapView
		-- r(3) = r(3).field(13) // EWorldMapView.MAP_VIEW_WORLD
		if registerVal2 == EWorldMapView.MAP_VIEW_REGION or registerVal2 == EWorldMapView.MAP_VIEW_WORLD then
			-- r(2) = g[14] // WorldMapAbility
			-- r(2) = r(2).field(15) // WorldMapAbility.IsMapAbilityAvailable
			-- r(3) = g[16] // EWorldMapAbility
			-- r(3) = r(3).field(17) // EWorldMapAbility.MAP_ABILITY_USE_FAST_TRAVEL_MARKER
			-- r(4) = r(0).field(18) // arg0.PlayerEntity
			registerVal2 = WorldMapAbility.IsMapAbilityAvailable(EWorldMapAbility.MAP_ABILITY_USE_FAST_TRAVEL_MARKER, arg0.PlayerEntity)
			-- skip the next [13] opcodes // advance 13 lines
			-- r(2) = g[19] // Level
			-- r(2) = r(2).field(20) // Level.IsTransitionAllowed
			registerVal2 = Level.IsTransitionAllowed()
			if registerVal2 and registerVal2 then
				-- r(2) = g[6] // EWorldMapModes
				-- r(2) = r(2).field(7) // EWorldMapModes.MAP_MODE_ZOOM
				-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
				-- r(3) = g[8] // EGameAction
				-- r(3) = r(3).field(9) // EGameAction.GAME_ACTION_WORLD_MAP_CONTEXT_SENSITIVE_ACTION_2
		-- OP Count: 0x5
		-- Constant Count: 0x1
		-- Registers Count: 0x3
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
				local function __FUNC_4580_()
					-- r(0) = r(0):c[0] // :PreConditionalTeleport
					-- r(2) = false
					:PreConditionalTeleport(false)
					-- return
				end

				-- r(0) = r(0) // arg0
				arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_CONTEXT_SENSITIVE_ACTION_2] = __FUNC_4580_
			end
		end
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x5F
	-- Constant Count: 0x17
	-- Registers Count: 0x5
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x4
function WorldMap.ProcessMoveMapItemToggle(arg0, arg1)
	-- r(2) = r(0).field(0) // arg0.State
	-- r(3) = g[1] // EWorldMapState
	-- r(3) = r(3).field(2) // EWorldMapState.MAP_STATE_MOVING_FAMILY
	-- skip the next [62] opcodes // advance 62 lines
	-- r(2) = r(0).field(0) // arg0.State
	-- r(3) = g[1] // EWorldMapState
	-- r(3) = r(3).field(3) // EWorldMapState.MAP_STATE_MOVING_SOLDIERS
	if arg0.State ~= EWorldMapState.MAP_STATE_MOVING_FAMILY and arg0.State ~= EWorldMapState.MAP_STATE_MOVING_SOLDIERS then
		-- r(2) = r(0).field(4) // arg0.Family
		-- skip the next [28] opcodes // advance 28 lines
		-- r(2) = r(0).field(4) // arg0.Family
		if arg0.Family and 0.000000 < #arg0.Family then
			-- r(2) = g[6] // WorldMapAbility
			-- r(2) = r(2).field(7) // WorldMapAbility.IsMapAbilityAvailable
			-- r(3) = g[8] // EWorldMapAbility
			-- r(3) = r(3).field(9) // EWorldMapAbility.MAP_ABILITY_MOVE_FAMILY
			-- r(4) = r(0).field(10) // arg0.PlayerEntity
			local registerVal2 = WorldMapAbility.IsMapAbilityAvailable(EWorldMapAbility.MAP_ABILITY_MOVE_FAMILY, arg0.PlayerEntity)
			-- skip the next [69] opcodes // advance 69 lines
			-- r(2) = g[11] // PlayerProperties
			-- r(2) = r(2).field(12) // PlayerProperties.GetNumberOfNonFamilyHouses
			-- r(3) = g[13] // GetGameOwningHeroFromGameWorld
			registerVal2 = PlayerProperties.GetNumberOfNonFamilyHouses(GetGameOwningHeroFromGameWorld())
			-- skip the next [62] opcodes // advance 62 lines
			-- r(2) = g[14] // EWorldMapModes
			-- r(2) = r(2).field(15) // EWorldMapModes.MAP_MODE_ZOOM
			-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
			-- r(3) = g[16] // EGameAction
			-- r(3) = r(3).field(17) // EGameAction.GAME_ACTION_WORLD_MAP_MOVE_MAP_ITEM_TOGGLE
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
			local function __FUNC_4B9E_()
				-- r(0) = r(0):c[0] // :PickupFamily
				:PickupFamily()
				-- return
			end

			-- r(0) = r(0) // arg0
			arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_MOVE_MAP_ITEM_TOGGLE] = __FUNC_4B9E_
			-- skip the next [53] opcodes // advance 53 lines
			-- r(2) = r(0).field(18) // arg0.Target
			-- skip the next [50] opcodes // advance 50 lines
			-- r(2) = r(0).field(18) // arg0.Target
			-- r(2) = r(2).field(19) // arg0.Target.Type
			-- r(3) = g[20] // EWorldMapEntityType
			-- r(3) = r(3).field(21) // EWorldMapEntityType.MAP_ENTITY_SOLDIER
			-- skip the next [44] opcodes // advance 44 lines
			-- r(2) = g[6] // WorldMapAbility
			-- r(2) = r(2).field(7) // WorldMapAbility.IsMapAbilityAvailable
			-- r(3) = g[8] // EWorldMapAbility
			-- r(3) = r(3).field(22) // EWorldMapAbility.MAP_ABILITY_MOVE_SOLDIERS
			-- r(4) = r(0).field(10) // arg0.PlayerEntity
			registerVal2 = WorldMapAbility.IsMapAbilityAvailable(EWorldMapAbility.MAP_ABILITY_MOVE_SOLDIERS, arg0.PlayerEntity)
			if registerVal2 and 0.000000 < registerVal2 and arg0.Target and arg0.Target.Type == EWorldMapEntityType.MAP_ENTITY_SOLDIER and registerVal2 then
				-- r(2) = g[14] // EWorldMapModes
				-- r(2) = r(2).field(15) // EWorldMapModes.MAP_MODE_ZOOM
				-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
				-- r(3) = g[16] // EGameAction
				-- r(3) = r(3).field(17) // EGameAction.GAME_ACTION_WORLD_MAP_MOVE_MAP_ITEM_TOGGLE
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
				local function __FUNC_4C59_()
					-- r(0) = r(0):c[0] // :PickupSoldiers
					:PickupSoldiers()
					-- return
				end

				-- r(0) = r(0) // arg0
				arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_MOVE_MAP_ITEM_TOGGLE] = __FUNC_4C59_
				-- skip the next [27] opcodes // advance 27 lines
			else
				-- r(2) = r(0).field(0) // arg0.State
				-- r(3) = g[1] // EWorldMapState
				-- r(3) = r(3).field(2) // EWorldMapState.MAP_STATE_MOVING_FAMILY
				if arg0.State == EWorldMapState.MAP_STATE_MOVING_FAMILY then
					-- r(2) = g[14] // EWorldMapModes
					-- r(2) = r(2).field(15) // EWorldMapModes.MAP_MODE_ZOOM
					-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
					-- r(3) = g[16] // EGameAction
					-- r(3) = r(3).field(17) // EGameAction.GAME_ACTION_WORLD_MAP_MOVE_MAP_ITEM_TOGGLE
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
					local function __FUNC_4D16_()
						-- r(0) = r(0):c[0] // :AskFamilyMovingQuestion
						:AskFamilyMovingQuestion()
						-- return
					end

					-- r(0) = r(0) // arg0
					arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_MOVE_MAP_ITEM_TOGGLE] = __FUNC_4D16_
					-- skip the next [13] opcodes // advance 13 lines
				else
					-- r(2) = r(0).field(0) // arg0.State
					-- r(3) = g[1] // EWorldMapState
					-- r(3) = r(3).field(3) // EWorldMapState.MAP_STATE_MOVING_SOLDIERS
					if arg0.State == EWorldMapState.MAP_STATE_MOVING_SOLDIERS then
						-- r(2) = g[14] // EWorldMapModes
						-- r(2) = r(2).field(15) // EWorldMapModes.MAP_MODE_ZOOM
						-- r(2) = r(1)[r(2)] // arg1[EWorldMapModes.MAP_MODE_ZOOM]
						-- r(3) = g[16] // EGameAction
						-- r(3) = r(3).field(17) // EGameAction.GAME_ACTION_WORLD_MAP_MOVE_MAP_ITEM_TOGGLE
		-- OP Count: 0x4
		-- Constant Count: 0x1
		-- Registers Count: 0x2
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
						local function __FUNC_4DDC_()
							-- r(0) = r(0):c[0] // :AskSoldierMovingQuestion
							:AskSoldierMovingQuestion()
							-- return
						end

						-- r(0) = r(0) // arg0
						arg1[EWorldMapModes.MAP_MODE_ZOOM][EGameAction.GAME_ACTION_WORLD_MAP_MOVE_MAP_ITEM_TOGGLE] = __FUNC_4DDC_
					end
				end
			end
		end
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x9C
	-- Constant Count: 0x26
	-- Registers Count: 0x13
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.ProcessScrollMapAction(arg0, arg1, arg2)
	-- r(3) = r(0).field(0) // arg0.Camera
	-- r(3) = r(3).field(1) // arg0.Camera.GetFacing
	local registerVal3 = arg0.Camera.GetFacing()
	-- r(3) = r(3):c[2] // registerVal3:GetCross
	-- r(5) = g[3] // CVector3
	-- r(6) = c[4] // 0.000000
	-- r(7) = c[4] // 0.000000
	-- r(8) = c[5] // 1.000000
	registerVal3 = registerVal3:GetCross(CVector3(0.000000, 0.000000, 1.000000))
	-- r(5) = r(0).field(0) // arg0.Camera
	-- r(5) = r(5).field(1) // arg0.Camera.GetFacing
	local registerVal5 = arg0.Camera.GetFacing()
	-- r(6) = g[3] // CVector3
	-- r(7) = r(5):c[6] // registerVal5:GetX
	local registerVal7 = registerVal5:GetX()
	-- r(8) = r(5):c[7] // registerVal5:GetY
	local registerVal8 = registerVal5:GetY()
	-- r(9) = c[4] // 0.000000
	local registerVal6 = CVector3(registerVal7, registerVal8, 0.000000)
	-- r(5) = r(6) // registerVal6
	-- r(6) = r(5):c[8] // registerVal6:NormaliseXY
	registerVal6:NormaliseXY()
	-- r(7) = r(0).field(9) // arg0.FocusPosition
	-- r(9) = true
	arg0.OutOfBoundsRatioKeyboard = 1.000000
	-- r(10) = r(0).field(11) // arg0.BoundsMarkers
	-- skip the next [34] opcodes // advance 34 lines
	-- r(10) = r(0).field(11) // arg0.BoundsMarkers
	-- skip the next [30] opcodes // advance 30 lines
	-- r(9) = false
	arg0.OutOfBoundsRatioKeyboard = 100.000000
	-- r(10) = g[13] // ipairs
	-- r(11) = r(0).field(11) // arg0.BoundsMarkers
	local registerVal10, registerVal11, registerVal12 = ipairs(arg0.BoundsMarkers)
	for index13,value14 in registerVal10, registerVal11, registerVal12 do
		-- skip the next [22] opcodes // advance 22 lines
		-- r(15) = r(14).field(14) // value14.Position
		-- r(16) = r(15):c[15] // (value14.Position - arg0.FocusPosition):GetLengthXY
		local registerVal16 = (value14.Position - arg0.FocusPosition):GetLengthXY()
		-- r(17) = r(14).field(16) // value14.Radius
		if registerVal16 < value14.Radius then
			-- r(9) = true
			arg0.OutOfBoundsRatioKeyboard = 1.000000
			-- skip the next [14] opcodes // advance 14 lines
			-- skip the next [11] opcodes // advance 11 lines
		else
			-- r(17) = r(14).field(16) // value14.Radius
			-- skip the next [8] opcodes // advance 8 lines
			-- r(17) = r(14).field(16) // value14.Radius
			-- r(18) = r(0).field(10) // arg0.OutOfBoundsRatioKeyboard
			if 0.000000 < value14.Radius and (registerVal16 / value14.Radius) < arg0.OutOfBoundsRatioKeyboard then
				arg0.OutOfBoundsRatioKeyboard = (registerVal16 / value14.Radius)
				-- r(18) = r(14).field(14) // value14.Position
				arg0.ClosestOutOfBoundsPosition = value14.Position
			end
		end
		-- skip the next [-24] opcodes // advance -24 lines
	end
	-- skip the next [23] opcodes // advance 23 lines
	-- r(10) = r(0).field(17) // arg0.ClosestOutOfBoundsPosition
	-- skip the next [20] opcodes // advance 20 lines
	-- r(10) = r(0).field(17) // arg0.ClosestOutOfBoundsPosition
	-- r(11) = r(10):c[19] // (arg0.ClosestOutOfBoundsPosition - arg0.FocusPosition):GetDot
	-- r(13) = r(8) // ((registerVal3 * arg1) + (registerVal6 * arg2))
	registerVal11 = (arg0.ClosestOutOfBoundsPosition - arg0.FocusPosition):GetDot(((registerVal3 * arg1) + (registerVal6 * arg2)))
	if true == false and arg0.ClosestOutOfBoundsPosition and registerVal11 < 0.000000 then
		-- r(11) = r(0).field(20) // arg0.MaxOutOfBoundsRatio
		-- r(12) = r(0).field(10) // arg0.OutOfBoundsRatioKeyboard
		-- r(12) = r(0).field(20) // arg0.MaxOutOfBoundsRatio
		-- r(12) = g[21] // math
		-- r(12) = r(12).field(22) // math.pow
		-- r(13) = r(11) // ((arg0.MaxOutOfBoundsRatio - arg0.OutOfBoundsRatioKeyboard) / (arg0.MaxOutOfBoundsRatio - 1.000000))
		-- r(14) = c[23] // 1.300000
		registerVal12 = math.pow(((arg0.MaxOutOfBoundsRatio - arg0.OutOfBoundsRatioKeyboard) / (arg0.MaxOutOfBoundsRatio - 1.000000)), 1.300000)
		-- r(11) = r(12) // registerVal12
	end
	-- r(10) = r(0).field(24) // arg0.CurrentMode
	-- r(11) = r(0).field(25) // arg0.Modes
	-- r(11) = r(11).field(26) // arg0.Modes.WorldView
	-- skip the next [24] opcodes // advance 24 lines
	-- r(10) = r(7):c[15] // arg0.FocusPosition:GetLengthXY
	registerVal10 = arg0.FocusPosition:GetLengthXY()
	-- r(11) = r(0).field(27) // arg0.MaxDistCursorMove
	-- skip the next [19] opcodes // advance 19 lines
	-- r(10) = r(7):c[19] // arg0.FocusPosition:GetDot
	-- r(12) = r(8) // (((registerVal3 * arg1) + (registerVal6 * arg2)) * registerVal12)
	registerVal10 = arg0.FocusPosition:GetDot((((registerVal3 * arg1) + (registerVal6 * arg2)) * registerVal12))
	if arg0.CurrentMode == arg0.Modes.WorldView and arg0.MaxDistCursorMove < registerVal10 and 0.000000 < registerVal10 then
		-- r(10) = g[3] // CVector3
		-- r(11) = r(7):c[7] // arg0.FocusPosition:GetY
		registerVal11 = arg0.FocusPosition:GetY()
		-- r(12) = r(7):c[6] // arg0.FocusPosition:GetX
		registerVal12 = arg0.FocusPosition:GetX()
		-- r(13) = c[4] // 0.000000
		registerVal10 = CVector3(-registerVal11, registerVal12, 0.000000)
		-- r(11) = r(10):c[8] // registerVal10:NormaliseXY
		registerVal10:NormaliseXY()
		-- r(11) = r(8):c[19] // (((registerVal3 * arg1) + (registerVal6 * arg2)) * registerVal12):GetDot
		-- r(13) = r(10) // registerVal10
		registerVal11 = (((registerVal3 * arg1) + (registerVal6 * arg2)) * registerVal12):GetDot(registerVal10)
	end
	-- r(10) = r(8):c[28] // (registerVal10 * registerVal11):GetLength
	registerVal10 = (registerVal10 * registerVal11):GetLength()
	if 0.000000 < registerVal10 then
		arg0.FramesSinceLastMoved = 0.000000
		-- r(10) = r(0).field(9) // arg0.FocusPosition
		arg0.FocusPosition = (arg0.FocusPosition + (registerVal10 * registerVal11))
	end
	-- r(10) = r(0).field(30) // arg0.MouseMove
	-- r(11) = g[3] // CVector3
	-- r(12) = c[4] // 0.000000
	-- r(13) = c[4] // 0.000000
	-- r(14) = c[4] // 0.000000
	registerVal11 = CVector3(0.000000, 0.000000, 0.000000)
	if arg0.MouseMove ~= registerVal11 then
		-- r(10) = r(0):c[31] // arg0:MoveCursor
		-- r(12) = r(0).field(30) // arg0.MouseMove
		-- r(13) = r(8) // (registerVal10 * registerVal11)
		arg0:MoveCursor(arg0.MouseMove, (registerVal10 * registerVal11))
		-- skip the next [14] opcodes // advance 14 lines
	else
		-- r(10) = r(0).field(32) // arg0.Cursor
		-- r(10) = r(10).field(33) // arg0.Cursor.Entity
		-- r(10) = r(10):c[34] // arg0.Cursor.Entity:GetFinalPos
		registerVal10 = arg0.Cursor.Entity:GetFinalPos()
		-- r(11) = r(0).field(35) // arg0.Animate
		-- r(12) = r(0).field(32) // arg0.Cursor
		local registerVal13 = {}
		local registerVal14 = {}
		local registerVal15 = {}
		registerVal15.Position = (registerVal10 + (registerVal10 * registerVal11))
		registerVal14[0.100000] = registerVal15
		registerVal13.Keyframes = registerVal14
		arg0.Animate(arg0.Cursor, registerVal13)
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x5E
	-- Constant Count: 0x1B
	-- Registers Count: 0x8
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.ProcessCursorAndCameraMovement(arg0, arg1, arg2)
	-- r(3) = r(0):c[0] // arg0:ShouldIgnoreStickInput
	local registerVal3 = arg0:ShouldIgnoreStickInput()
	if registerVal3 then
		-- r(3) = g[2] // CVector3
		-- r(4) = c[3] // 0.000000
		-- r(5) = c[3] // 0.000000
		-- r(6) = c[3] // 0.000000
		registerVal3 = CVector3(0.000000, 0.000000, 0.000000)
		arg0.ControlDirection = registerVal3
		return 
	end
	-- r(3) = c[4] // -5.000000
	-- r(4) = c[4] // -5.000000
	-- r(5) = g[5] // EGameAction
	-- r(5) = r(5).field(6) // EGameAction.GAME_ACTION_WORLD_MAP_ORBIT_CAMERA
	if arg1 ~= EGameAction.GAME_ACTION_WORLD_MAP_ORBIT_CAMERA then
		arg0.ControlDirection = arg2
		-- r(5) = r(0).field(7) // arg0.UserRotationCounter
		if 0.000000 < arg0.UserRotationCounter then
			-- r(5) = r(0).field(7) // arg0.UserRotationCounter
			arg0.UserRotationCounter = (arg0.UserRotationCounter - 1.000000)
		end
		-- r(5) = r(0).field(7) // arg0.UserRotationCounter
		if arg0.UserRotationCounter == 0.000000 then
			arg0.UserRotation = 0.000000
			-- skip the next [64] opcodes // advance 64 lines
		else
			-- r(5) = r(0).field(10) // arg0.AllowUserControlledCamera
			if arg0.AllowUserControlledCamera then
				-- r(5) = r(0).field(11) // arg0.YawAdjustment
				-- r(6) = r(2):c[12] // arg2:GetX
				local registerVal6 = arg2:GetX()
				arg0.YawAdjustment = (arg0.YawAdjustment + (registerVal6 * -5.000000))
				-- r(5) = r(0).field(13) // arg0.DistanceAdjustment
				-- r(6) = r(2):c[14] // arg2:GetY
				registerVal6 = arg2:GetY()
				arg0.DistanceAdjustment = (arg0.DistanceAdjustment + (-5.000000 * registerVal6))
				arg0.UserRotation = 0.000000
				arg0.FramesSinceLastMoved = 0.000000
				-- skip the next [46] opcodes // advance 46 lines
			else
				-- r(5) = r(0).field(16) // arg0.AllowRotation
				-- skip the next [43] opcodes // advance 43 lines
				-- r(5) = r(0).field(17) // arg0.CurrentMode
				-- r(6) = r(0).field(18) // arg0.Modes
				-- r(6) = r(6).field(19) // arg0.Modes.RegionView
				if arg0.AllowRotation and arg0.CurrentMode == arg0.Modes.RegionView then
					-- r(5) = c[3] // 0.000000
					-- r(6) = r(0).field(20) // arg0.CameraRotationMode
					-- r(7) = g[21] // EWorldMapCameraState
					-- r(7) = r(7).field(22) // EWorldMapCameraState.CAMERA_STATE_FULL_ROTATION
					if arg0.CameraRotationMode == EWorldMapCameraState.CAMERA_STATE_FULL_ROTATION then
						-- r(6) = r(0).field(7) // arg0.UserRotationCounter
						if arg0.UserRotationCounter == 0.000000 then
							-- r(5) = r(0).field(11) // arg0.YawAdjustment
							-- skip the next [1] opcodes // advance 1 lines
						else
							-- r(5) = r(0).field(9) // arg0.UserRotation
						end
						-- r(6) = r(2):c[12] // arg2:GetX
						registerVal6 = arg2:GetX()
						if (arg0.UserRotation + (registerVal6 * -5.000000)) < 0.000000 then
							-- skip the next [12] opcodes // advance 12 lines
						else
							-- skip the next [10] opcodes // advance 10 lines
							-- skip the next [8] opcodes // advance 8 lines
							-- r(6) = r(0).field(20) // arg0.CameraRotationMode
							-- r(7) = g[21] // EWorldMapCameraState
							-- r(7) = r(7).field(24) // EWorldMapCameraState.CAMERA_STATE_LIMITED_ROTATION
							if 360.000000 < ((arg0.UserRotation + (registerVal6 * -5.000000)) + 360.000000) and arg0.CameraRotationMode == EWorldMapCameraState.CAMERA_STATE_LIMITED_ROTATION then
								-- r(6) = r(2):c[12] // arg2:GetX
								registerVal6 = arg2:GetX()
							end
						end
					end
					arg0.UserRotationCounter = 30.000000
					-- r(6) = r(0).field(9) // arg0.UserRotation
					if arg0.UserRotation ~= (registerVal6 * 90.000000) then
						arg0.FramesSinceLastMoved = 0.000000
					end
					arg0.UserRotation = (registerVal6 * 90.000000)
				end
			end
		end
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x4B
	-- Constant Count: 0xA
	-- Registers Count: 0x7
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x8
function WorldMap.ProcessButtonHeld(arg0, arg1)
	-- r(2) = r(0):c[0] // arg0:ShouldIgnoreButtonInput
	local registerVal2 = arg0:ShouldIgnoreButtonInput()
	if registerVal2 then
		return 
	end
	-- r(3) = g[1] // EWorldMapModes
	-- r(3) = r(3).field(2) // EWorldMapModes.MAP_MODE_ZOOM
	local registerVal4 = {}
	-- r(5) = r(0).field(3) // arg0.PadButtons
	-- r(5) = r(5).field(4) // arg0.PadButtons.LeftBumper
		-- OP Count: 0x5
		-- Constant Count: 0x2
		-- Registers Count: 0x3
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
	local function __FUNC_6269_()
		-- r(0) = r(0):c[0] // :TiltCamera
		-- r(2) = c[1] // -1.000000
		:TiltCamera(-1.000000)
		-- return
	end

	-- r(0) = r(0) // arg0
	registerVal4[arg0.PadButtons.LeftBumper] = __FUNC_6269_
	-- r(5) = r(0).field(3) // arg0.PadButtons
	-- r(5) = r(5).field(5) // arg0.PadButtons.RightBumper
		-- OP Count: 0x5
		-- Constant Count: 0x2
		-- Registers Count: 0x3
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
	local function __FUNC_632F_()
		-- r(0) = r(0):c[0] // :TiltCamera
		-- r(2) = c[1] // 1.000000
		:TiltCamera(1.000000)
		-- return
	end

	-- r(0) = r(0) // arg0
	registerVal4[arg0.PadButtons.RightBumper] = __FUNC_632F_
	{}[EWorldMapModes.MAP_MODE_ZOOM] = registerVal4
	-- r(3) = g[1] // EWorldMapModes
	-- r(3) = r(3).field(6) // EWorldMapModes.MAP_MODE_QUEST_GIVER
	registerVal4 = {}
	-- r(5) = r(0).field(3) // arg0.PadButtons
	-- r(5) = r(5).field(4) // arg0.PadButtons.LeftBumper
		-- OP Count: 0x5
		-- Constant Count: 0x2
		-- Registers Count: 0x3
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
	local function __FUNC_63F5_()
		-- r(0) = r(0):c[0] // :TiltCamera
		-- r(2) = c[1] // -1.000000
		:TiltCamera(-1.000000)
		-- return
	end

	-- r(0) = r(0) // arg0
	registerVal4[arg0.PadButtons.LeftBumper] = __FUNC_63F5_
	-- r(5) = r(0).field(3) // arg0.PadButtons
	-- r(5) = r(5).field(5) // arg0.PadButtons.RightBumper
		-- OP Count: 0x5
		-- Constant Count: 0x2
		-- Registers Count: 0x3
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
	local function __FUNC_64BB_()
		-- r(0) = r(0):c[0] // :TiltCamera
		-- r(2) = c[1] // 1.000000
		:TiltCamera(1.000000)
		-- return
	end

	-- r(0) = r(0) // arg0
	registerVal4[arg0.PadButtons.RightBumper] = __FUNC_64BB_
	{}[EWorldMapModes.MAP_MODE_QUEST_GIVER] = registerVal4
	-- r(3) = g[1] // EWorldMapModes
	-- r(3) = r(3).field(7) // EWorldMapModes.MAP_MODE_HOUSE
	registerVal4 = {}
	-- r(5) = r(0).field(3) // arg0.PadButtons
	-- r(5) = r(5).field(4) // arg0.PadButtons.LeftBumper
		-- OP Count: 0x5
		-- Constant Count: 0x2
		-- Registers Count: 0x3
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
	local function __FUNC_6581_()
		-- r(0) = r(0):c[0] // :TiltCamera
		-- r(2) = c[1] // -1.000000
		:TiltCamera(-1.000000)
		-- return
	end

	-- r(0) = r(0) // arg0
	registerVal4[arg0.PadButtons.LeftBumper] = __FUNC_6581_
	-- r(5) = r(0).field(3) // arg0.PadButtons
	-- r(5) = r(5).field(5) // arg0.PadButtons.RightBumper
		-- OP Count: 0x5
		-- Constant Count: 0x2
		-- Registers Count: 0x3
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
	local function __FUNC_6647_()
		-- r(0) = r(0):c[0] // :TiltCamera
		-- r(2) = c[1] // 1.000000
		:TiltCamera(1.000000)
		-- return
	end

	-- r(0) = r(0) // arg0
	registerVal4[arg0.PadButtons.RightBumper] = __FUNC_6647_
	{}[EWorldMapModes.MAP_MODE_HOUSE] = registerVal4
	-- r(3) = g[1] // EWorldMapModes
	-- r(3) = r(3).field(8) // EWorldMapModes.MAP_MODE_RULER_BOARD
	registerVal4 = {}
	-- r(5) = r(0).field(3) // arg0.PadButtons
	-- r(5) = r(5).field(4) // arg0.PadButtons.LeftBumper
		-- OP Count: 0x5
		-- Constant Count: 0x2
		-- Registers Count: 0x3
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
	local function __FUNC_670D_()
		-- r(0) = r(0):c[0] // :TiltCamera
		-- r(2) = c[1] // -1.000000
		:TiltCamera(-1.000000)
		-- return
	end

	-- r(0) = r(0) // arg0
	registerVal4[arg0.PadButtons.LeftBumper] = __FUNC_670D_
	-- r(5) = r(0).field(3) // arg0.PadButtons
	-- r(5) = r(5).field(5) // arg0.PadButtons.RightBumper
		-- OP Count: 0x5
		-- Constant Count: 0x2
		-- Registers Count: 0x3
		-- UpValue Count: 0x1
		-- SubFuncs Count: 0x0
	local function __FUNC_67D3_()
		-- r(0) = r(0):c[0] // :TiltCamera
		-- r(2) = c[1] // 1.000000
		:TiltCamera(1.000000)
		-- return
	end

	-- r(0) = r(0) // arg0
	registerVal4[arg0.PadButtons.RightBumper] = __FUNC_67D3_
	{}[EWorldMapModes.MAP_MODE_RULER_BOARD] = registerVal4
	-- r(3) = nil
	-- r(4) = r(0).field(9) // arg0.Mode
	-- r(4) = r(2)[r(4)] // {}[arg0.Mode]
	if {}[arg0.Mode] then
		-- r(4) = r(0).field(9) // arg0.Mode
		-- r(4) = r(2)[r(4)] // {}[arg0.Mode]
		-- r(3) = r(4)[r(1)] // {}[arg0.Mode][arg1]
	end
	if {}[arg0.Mode][arg1] then
		-- r(4) = r(3) // {}[arg0.Mode][arg1]
		{}[arg0.Mode][arg1]()
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x2F
	-- Constant Count: 0xD
	-- Registers Count: 0xD
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.DistanceMultiplier(arg0, arg1)
	-- r(2) = r(0).field(0) // arg0.CurrentMode
	-- r(2) = r(2).field(1) // arg0.CurrentMode.MaxDistanceTillFullSpeed
	-- r(3) = g[2] // pairs
	-- r(4) = r(0).field(3) // arg0.Regions
	local registerVal3, registerVal4, registerVal5 = pairs(arg0.Regions)
	for index6,value7 in registerVal3, registerVal4, registerVal5 do
		-- skip the next [26] opcodes // advance 26 lines
		-- r(8) = g[4] // WorldMap
		-- r(8) = r(8).field(3) // WorldMap.Regions
		-- r(8) = r(8).field(5) // WorldMap.Regions.TEXT_REGION_WORLD_MAP
		-- skip the next [21] opcodes // advance 21 lines
		-- r(8) = r(7).field(6) // value7.Centre
		-- r(8) = r(8):c[7] // value7.Centre:GetX
		local registerVal8 = value7.Centre:GetX()
		-- r(9) = r(1):c[7] // arg1:GetX
		local registerVal9 = arg1:GetX()
		-- r(9) = r(7).field(6) // value7.Centre
		-- r(9) = r(9):c[8] // value7.Centre:GetY
		registerVal9 = value7.Centre:GetY()
		-- r(10) = r(1):c[8] // arg1:GetY
		local registerVal10 = arg1:GetY()
		-- r(10) = g[9] // math
		-- r(10) = r(10).field(10) // math.sqrt
		registerVal10 = math.sqrt((((registerVal8 - registerVal9) * (registerVal8 - registerVal9)) + ((registerVal9 - registerVal10) * (registerVal9 - registerVal10))))
		if value7 ~= WorldMap.Regions.TEXT_REGION_WORLD_MAP and registerVal10 < arg0.CurrentMode.MaxDistanceTillFullSpeed then
			-- r(2) = r(10) // registerVal10
		end
		-- skip the next [-28] opcodes // advance -28 lines
	end
	-- r(3) = r(0).field(0) // arg0.CurrentMode
	-- r(3) = r(3).field(1) // arg0.CurrentMode.MaxDistanceTillFullSpeed
	-- r(4) = r(0).field(0) // arg0.CurrentMode
	-- r(4) = r(4).field(11) // arg0.CurrentMode.TotalExtraMovementMultiplier
	if ((registerVal10 / arg0.CurrentMode.MaxDistanceTillFullSpeed) * arg0.CurrentMode.TotalExtraMovementMultiplier) < 1.000000 then
		-- r(4) = c[12] // 1.000000
		return 1.000000
		-- skip the next [1] opcodes // advance 1 lines
	else
		return ((registerVal10 / arg0.CurrentMode.MaxDistanceTillFullSpeed) * arg0.CurrentMode.TotalExtraMovementMultiplier)
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x61
	-- Constant Count: 0x1C
	-- Registers Count: 0xD
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.RestrictCursorMovement(arg0, arg1, arg2, arg3, arg4)
	-- r(5) = r(0).field(0) // arg0.CurrentMode
	-- r(5) = r(5).field(1) // arg0.CurrentMode.MovementMultiplier
	-- r(6) = r(2):c[2] // arg2:GetCross
	-- r(8) = g[3] // CVector3
	-- r(9) = c[4] // 0.000000
	-- r(10) = c[4] // 0.000000
	-- r(11) = c[5] // 1.000000
	local registerVal6 = arg2:GetCross(CVector3(0.000000, 0.000000, 1.000000))
	-- r(7) = r(1):c[6] // arg1:GetX
	local registerVal7 = arg1:GetX()
	-- r(8) = r(1):c[7] // arg1:GetY
	local registerVal8 = arg1:GetY()
	-- r(8) = r(0).field(8) // arg0.InBounds
	if arg0.InBounds == false then
		-- r(8) = r(0).field(10) // arg0.ClosestOutOfBoundsPosition
		-- skip the next [43] opcodes // advance 43 lines
		-- r(8) = r(0).field(10) // arg0.ClosestOutOfBoundsPosition
		-- r(9) = r(0).field(11) // arg0.Cursor
		-- r(9) = r(9).field(12) // arg0.Cursor.Entity
		-- r(9) = r(9):c[13] // arg0.Cursor.Entity:GetPos
		local registerVal9 = arg0.Cursor.Entity:GetPos()
		-- r(9) = r(8):c[14] // (arg0.ClosestOutOfBoundsPosition - registerVal9):GetDot
		-- r(11) = r(7) // ((registerVal6 * registerVal7) + (arg2 * registerVal8))
		registerVal9 = (arg0.ClosestOutOfBoundsPosition - registerVal9):GetDot(((registerVal6 * registerVal7) + (arg2 * registerVal8)))
		-- skip the next [32] opcodes // advance 32 lines
		-- r(9) = r(0).field(15) // arg0.MaxOutOfBoundsRatio
		-- r(10) = r(0).field(16) // arg0.OutOfBoundsRatio
		-- r(10) = r(0).field(15) // arg0.MaxOutOfBoundsRatio
		-- r(10) = g[17] // math
		-- r(10) = r(10).field(18) // math.pow
		-- r(11) = r(9) // ((arg0.MaxOutOfBoundsRatio - arg0.OutOfBoundsRatio) / (arg0.MaxOutOfBoundsRatio - 1.000000))
		-- r(12) = c[19] // 1.300000
		local registerVal10 = math.pow(((arg0.MaxOutOfBoundsRatio - arg0.OutOfBoundsRatio) / (arg0.MaxOutOfBoundsRatio - 1.000000)), 1.300000)
		-- r(9) = r(10) // registerVal10
		-- skip the next [18] opcodes // advance 18 lines
		-- skip the next [16] opcodes // advance 16 lines
		-- r(8) = r(0).field(0) // arg0.CurrentMode
		-- r(9) = g[20] // WorldMap
		-- r(9) = r(9).field(21) // WorldMap.Modes
		-- r(9) = r(9).field(22) // WorldMap.Modes.WorldView
		-- skip the next [10] opcodes // advance 10 lines
		-- r(8) = r(0).field(23) // arg0.CursorAndScrollingLinked
		if arg0.ClosestOutOfBoundsPosition and registerVal9 < 0.000000 and arg4 and arg0.CurrentMode == WorldMap.Modes.WorldView and arg0.CursorAndScrollingLinked then
			-- r(8) = r(0):c[24] // arg0:DistanceMultiplier
			-- r(10) = r(0).field(11) // arg0.Cursor
			-- r(10) = r(10).field(12) // arg0.Cursor.Entity
			-- r(10) = r(10):c[13] // arg0.Cursor.Entity:GetPos
			registerVal8 = arg0:DistanceMultiplier(arg0.Cursor.Entity:GetPos())
		end
	end
	-- r(8) = r(0).field(0) // arg0.CurrentMode
	-- r(9) = r(0).field(21) // arg0.Modes
	-- r(9) = r(9).field(22) // arg0.Modes.WorldView
	-- skip the next [24] opcodes // advance 24 lines
	-- r(8) = r(3):c[25] // arg3:GetLengthXY
	registerVal8 = arg3:GetLengthXY()
	-- r(9) = r(0).field(26) // arg0.MaxDistCursorMove
	-- skip the next [19] opcodes // advance 19 lines
	-- r(8) = r(3):c[14] // arg3:GetDot
	-- r(10) = r(7) // (((registerVal6 * registerVal7) + (arg2 * registerVal8)) * ((arg0.CurrentMode.MovementMultiplier * registerVal10) * registerVal8))
	registerVal8 = arg3:GetDot((((registerVal6 * registerVal7) + (arg2 * registerVal8)) * ((arg0.CurrentMode.MovementMultiplier * registerVal10) * registerVal8)))
	if arg0.CurrentMode == arg0.Modes.WorldView and arg0.MaxDistCursorMove < registerVal8 and 0.000000 < registerVal8 then
		-- r(8) = g[3] // CVector3
		-- r(9) = r(3):c[7] // arg3:GetY
		registerVal9 = arg3:GetY()
		-- r(10) = r(3):c[6] // arg3:GetX
		registerVal10 = arg3:GetX()
		-- r(11) = c[4] // 0.000000
		registerVal8 = CVector3(-registerVal9, registerVal10, 0.000000)
		-- r(9) = r(8):c[27] // registerVal8:NormaliseXY
		registerVal8:NormaliseXY()
		-- r(9) = r(7):c[14] // (((registerVal6 * registerVal7) + (arg2 * registerVal8)) * ((arg0.CurrentMode.MovementMultiplier * registerVal10) * registerVal8)):GetDot
		-- r(11) = r(8) // registerVal8
		registerVal9 = (((registerVal6 * registerVal7) + (arg2 * registerVal8)) * ((arg0.CurrentMode.MovementMultiplier * registerVal10) * registerVal8)):GetDot(registerVal8)
	end
	return (registerVal8 * registerVal9)
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x9D
	-- Constant Count: 0x1B
	-- Registers Count: 0xD
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.MoveCameraBasedOnCursor(arg0, arg1, arg2)
	-- r(3) = r(0).field(0) // arg0.Cursor
	-- r(3) = r(3).field(1) // arg0.Cursor.Entity
	-- r(3) = r(3):c[2] // arg0.Cursor.Entity:GetPos
	local registerVal3 = arg0.Cursor.Entity:GetPos()
	-- r(4) = r(0).field(3) // arg0.GetXPositionInScreen
	-- r(5) = r(3):c[4] // registerVal3:GetX
	local registerVal5 = registerVal3:GetX()
	-- r(6) = r(3):c[5] // registerVal3:GetY
	local registerVal6 = registerVal3:GetY()
	-- r(7) = r(3):c[6] // registerVal3:GetZ
	local registerVal4 = arg0.GetXPositionInScreen(registerVal5, registerVal6, registerVal3:GetZ())
	-- r(5) = r(0).field(7) // arg0.GetYPositionInScreen
	-- r(6) = r(3):c[4] // registerVal3:GetX
	registerVal6 = registerVal3:GetX()
	-- r(7) = r(3):c[5] // registerVal3:GetY
	local registerVal7 = registerVal3:GetY()
	-- r(8) = r(3):c[6] // registerVal3:GetZ
	registerVal5 = arg0.GetYPositionInScreen(registerVal6, registerVal7, registerVal3:GetZ())
	-- r(6) = g[8] // CVector3
	-- r(7) = c[9] // 0.000000
	-- r(8) = c[9] // 0.000000
	-- r(9) = c[9] // 0.000000
	registerVal6 = CVector3(0.000000, 0.000000, 0.000000)
	-- r(7) = r(0).field(10) // arg0.XCursorBoundaryMax
	-- skip the next [4] opcodes // advance 4 lines
	-- r(7) = r(1):c[4] // arg1:GetX
	registerVal7 = arg1:GetX()
	if arg0.XCursorBoundaryMax >= registerVal4 or 0.000000 >= registerVal7 then
		-- r(7) = r(0).field(11) // arg0.XCursorBoundaryMin
		-- skip the next [29] opcodes // advance 29 lines
		-- r(7) = r(1):c[4] // arg1:GetX
		registerVal7 = arg1:GetX()
		if registerVal4 < arg0.XCursorBoundaryMin and registerVal7 < 0.000000 then
			-- r(7) = r(0).field(12) // arg0.Camera
			-- r(7) = r(7).field(13) // arg0.Camera.GetUp
			registerVal7 = arg0.Camera.GetUp()
			-- r(7) = r(7):c[14] // registerVal7:GetCross
			-- r(9) = g[8] // CVector3
			-- r(10) = c[9] // 0.000000
			-- r(11) = c[9] // 0.000000
			-- r(12) = c[15] // 1.000000
			registerVal7 = registerVal7:GetCross(CVector3(0.000000, 0.000000, 1.000000))
			-- r(8) = g[8] // CVector3
			-- r(9) = r(7):c[4] // registerVal7:GetX
			local registerVal9 = registerVal7:GetX()
			-- r(10) = r(7):c[5] // registerVal7:GetY
			local registerVal10 = registerVal7:GetY()
			-- r(11) = c[9] // 0.000000
			local registerVal8 = CVector3(registerVal9, registerVal10, 0.000000)
			-- r(7) = r(8) // registerVal8
			-- r(8) = r(7):c[16] // registerVal8:NormaliseXY
			registerVal8:NormaliseXY()
			-- r(8) = r(7):c[17] // registerVal8:GetDot
			registerVal8 = registerVal8:GetDot((arg2 * 0.500000))
		end
	end
	-- r(7) = r(0).field(19) // arg0.YCursorBoundaryMax
	-- skip the next [4] opcodes // advance 4 lines
	-- r(7) = r(1):c[5] // arg1:GetY
	registerVal7 = arg1:GetY()
	if arg0.YCursorBoundaryMax >= registerVal5 or registerVal7 >= 0.000000 then
		-- r(7) = r(0).field(20) // arg0.YCursorBoundaryMin
		-- skip the next [24] opcodes // advance 24 lines
		-- r(7) = r(1):c[5] // arg1:GetY
		registerVal7 = arg1:GetY()
		if registerVal5 < arg0.YCursorBoundaryMin and 0.000000 < registerVal7 then
			-- r(7) = g[8] // CVector3
			-- r(8) = r(0).field(12) // arg0.Camera
			-- r(8) = r(8).field(13) // arg0.Camera.GetUp
			registerVal8 = arg0.Camera.GetUp()
			-- r(8) = r(8):c[4] // registerVal8:GetX
			registerVal8 = registerVal8:GetX()
			-- r(9) = r(0).field(12) // arg0.Camera
			-- r(9) = r(9).field(13) // arg0.Camera.GetUp
			registerVal9 = arg0.Camera.GetUp()
			-- r(9) = r(9):c[5] // registerVal9:GetY
			registerVal9 = registerVal9:GetY()
			-- r(10) = c[9] // 0.000000
			registerVal7 = CVector3(registerVal8, registerVal9, 0.000000)
			-- r(8) = r(7):c[16] // registerVal7:NormaliseXY
			registerVal7:NormaliseXY()
			-- r(8) = r(7):c[17] // registerVal7:GetDot
			registerVal8 = registerVal7:GetDot((arg2 * 0.500000))
		end
	end
	-- r(7) = g[8] // CVector3
	-- r(8) = c[9] // 0.000000
	-- r(9) = c[9] // 0.000000
	-- r(10) = c[9] // 0.000000
	registerVal7 = CVector3(0.000000, 0.000000, 0.000000)
	if ((registerVal6 + (registerVal8 * registerVal8)) + (registerVal7 * registerVal8)) ~= registerVal7 then
		-- r(7) = r(0).field(21) // arg0.CurrentMode
		-- r(8) = r(0).field(22) // arg0.Modes
		-- r(8) = r(8).field(23) // arg0.Modes.WorldView
		-- skip the next [28] opcodes // advance 28 lines
		-- r(7) = r(0).field(24) // arg0.FocusPosition
		-- r(7) = r(7):c[25] // arg0.FocusPosition:GetLengthXY
		registerVal7 = arg0.FocusPosition:GetLengthXY()
		-- r(8) = r(0).field(26) // arg0.MaxDistCursorMove
		-- skip the next [22] opcodes // advance 22 lines
		-- r(7) = r(0).field(24) // arg0.FocusPosition
		-- r(7) = r(7):c[17] // arg0.FocusPosition:GetDot
		-- r(9) = r(6) // ((registerVal6 + (registerVal8 * registerVal8)) + (registerVal7 * registerVal8))
		registerVal7 = arg0.FocusPosition:GetDot(((registerVal6 + (registerVal8 * registerVal8)) + (registerVal7 * registerVal8)))
		if arg0.CurrentMode == arg0.Modes.WorldView and arg0.MaxDistCursorMove < registerVal7 and 0.000000 < registerVal7 then
			-- r(7) = g[8] // CVector3
			-- r(8) = r(0).field(24) // arg0.FocusPosition
			-- r(8) = r(8):c[5] // arg0.FocusPosition:GetY
			registerVal8 = arg0.FocusPosition:GetY()
			-- r(9) = r(0).field(24) // arg0.FocusPosition
			-- r(9) = r(9):c[4] // arg0.FocusPosition:GetX
			registerVal9 = arg0.FocusPosition:GetX()
			-- r(10) = c[9] // 0.000000
			registerVal7 = CVector3(-registerVal8, registerVal9, 0.000000)
			-- r(8) = r(7):c[16] // registerVal7:NormaliseXY
			registerVal7:NormaliseXY()
			-- r(8) = r(6):c[17] // ((registerVal6 + (registerVal8 * registerVal8)) + (registerVal7 * registerVal8)):GetDot
			-- r(10) = r(7) // registerVal7
			registerVal8 = ((registerVal6 + (registerVal8 * registerVal8)) + (registerVal7 * registerVal8)):GetDot(registerVal7)
		end
		-- r(7) = g[8] // CVector3
		-- r(8) = r(0).field(24) // arg0.FocusPosition
		-- r(8) = r(8):c[4] // arg0.FocusPosition:GetX
		registerVal8 = arg0.FocusPosition:GetX()
		-- r(9) = r(6):c[4] // (registerVal7 * registerVal8):GetX
		registerVal9 = (registerVal7 * registerVal8):GetX()
		-- r(9) = r(0).field(24) // arg0.FocusPosition
		-- r(9) = r(9):c[5] // arg0.FocusPosition:GetY
		registerVal9 = arg0.FocusPosition:GetY()
		-- r(10) = r(6):c[5] // (registerVal7 * registerVal8):GetY
		registerVal10 = (registerVal7 * registerVal8):GetY()
		-- r(10) = r(0).field(24) // arg0.FocusPosition
		-- r(10) = r(10):c[6] // arg0.FocusPosition:GetZ
		registerVal7 = CVector3((registerVal8 + registerVal9), (registerVal9 + registerVal10), arg0.FocusPosition:GetZ())
		arg0.FocusPosition = registerVal7
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x2F
	-- Constant Count: 0xF
	-- Registers Count: 0xB
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.StopCameraIfCursorGoingOffScreen(arg0, arg1, arg2, arg3)
	-- r(4) = r(0).field(0) // arg0.Cursor
	-- r(4) = r(4).field(1) // arg0.Cursor.Entity
	-- r(4) = r(4):c[2] // arg0.Cursor.Entity:GetPos
	local registerVal4 = arg0.Cursor.Entity:GetPos()
	-- r(5) = r(0).field(3) // arg0.GetXPositionInScreen
	-- r(6) = r(4):c[4] // registerVal4:GetX
	local registerVal6 = registerVal4:GetX()
	-- r(7) = r(4):c[5] // registerVal4:GetY
	local registerVal7 = registerVal4:GetY()
	-- r(8) = r(4):c[6] // registerVal4:GetZ
	local registerVal5 = arg0.GetXPositionInScreen(registerVal6, registerVal7, registerVal4:GetZ())
	-- r(6) = r(0).field(7) // arg0.GetYPositionInScreen
	-- r(7) = r(4):c[4] // registerVal4:GetX
	registerVal7 = registerVal4:GetX()
	-- r(8) = r(4):c[5] // registerVal4:GetY
	local registerVal8 = registerVal4:GetY()
	-- r(9) = r(4):c[6] // registerVal4:GetZ
	registerVal6 = arg0.GetYPositionInScreen(registerVal7, registerVal8, registerVal4:GetZ())
	-- r(7) = r(0).field(8) // arg0.XCursorBoundaryMax
	-- skip the next [2] opcodes // advance 2 lines
	if arg0.XCursorBoundaryMax >= registerVal5 or 0.000000 >= arg2 then
		-- r(7) = r(0).field(10) // arg0.XCursorBoundaryMin
		-- skip the next [2] opcodes // advance 2 lines
		if registerVal5 >= arg0.XCursorBoundaryMin or arg2 >= 0.000000 then
			-- r(7) = r(0).field(11) // arg0.YCursorBoundaryMax
			-- skip the next [2] opcodes // advance 2 lines
			if arg0.YCursorBoundaryMax >= registerVal6 or arg3 >= 0.000000 then
				-- r(7) = r(0).field(12) // arg0.YCursorBoundaryMin
				-- skip the next [8] opcodes // advance 8 lines
				if registerVal6 < arg0.YCursorBoundaryMin and 0.000000 < arg3 then
					-- r(7) = r(0).field(13) // arg0.FocusPosition
					-- r(8) = r(0).field(13) // arg0.FocusPosition
					arg0.FocusPosition = (arg0.FocusPosition + ((arg1 - arg0.FocusPosition) * 0.500000))
				end
			end
		end
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x34
	-- Constant Count: 0xD
	-- Registers Count: 0xB
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.KeepCursorOnScreen(arg0, arg1, arg2, arg3)
	-- r(4) = r(0).field(0) // arg0.Cursor
	-- r(4) = r(4).field(1) // arg0.Cursor.Entity
	-- r(4) = r(4):c[2] // arg0.Cursor.Entity:GetPos
	local registerVal4 = arg0.Cursor.Entity:GetPos()
	-- r(5) = r(0).field(3) // arg0.GetXPositionInScreen
	-- r(6) = r(4):c[4] // (registerVal4 + arg2):GetX
	local registerVal6 = (registerVal4 + arg2):GetX()
	-- r(7) = r(4):c[5] // (registerVal4 + arg2):GetY
	local registerVal7 = (registerVal4 + arg2):GetY()
	-- r(8) = r(4):c[6] // (registerVal4 + arg2):GetZ
	local registerVal5 = arg0.GetXPositionInScreen(registerVal6, registerVal7, (registerVal4 + arg2):GetZ())
	-- r(6) = r(0).field(7) // arg0.GetYPositionInScreen
	-- r(7) = r(4):c[4] // (registerVal4 + arg2):GetX
	registerVal7 = (registerVal4 + arg2):GetX()
	-- r(8) = r(4):c[5] // (registerVal4 + arg2):GetY
	local registerVal8 = (registerVal4 + arg2):GetY()
	-- r(9) = r(4):c[6] // (registerVal4 + arg2):GetZ
	registerVal6 = arg0.GetYPositionInScreen(registerVal7, registerVal8, (registerVal4 + arg2):GetZ())
	-- r(7) = r(0).field(8) // arg0.XCursorBoundaryMax
	-- skip the next [4] opcodes // advance 4 lines
	-- r(7) = r(1):c[4] // arg1:GetX
	registerVal7 = arg1:GetX()
	if arg0.XCursorBoundaryMax >= registerVal5 or 0.000000 >= registerVal7 then
		-- r(7) = r(0).field(10) // arg0.XCursorBoundaryMin
		-- skip the next [4] opcodes // advance 4 lines
		-- r(7) = r(1):c[4] // arg1:GetX
		registerVal7 = arg1:GetX()
		if registerVal5 >= arg0.XCursorBoundaryMin or registerVal7 >= 0.000000 then
			-- r(7) = r(0).field(11) // arg0.YCursorBoundaryMax
			-- skip the next [4] opcodes // advance 4 lines
			-- r(7) = r(1):c[5] // arg1:GetY
			registerVal7 = arg1:GetY()
			if arg0.YCursorBoundaryMax >= registerVal6 or registerVal7 >= 0.000000 then
				-- r(7) = r(0).field(12) // arg0.YCursorBoundaryMin
				-- skip the next [5] opcodes // advance 5 lines
				-- r(7) = r(1):c[5] // arg1:GetY
				registerVal7 = arg1:GetY()
				if registerVal6 < arg0.YCursorBoundaryMin and 0.000000 < registerVal7 then
					return arg3
				end
			end
		end
	end
	return arg2
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x53
	-- Constant Count: 0x1C
	-- Registers Count: 0xD
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.MoveCursor(arg0, arg1, arg2)
	-- r(3) = r(0).field(0) // arg0.Camera
	-- r(3) = r(3).field(1) // arg0.Camera.GetFacing
	local registerVal3 = arg0.Camera.GetFacing()
	-- r(4) = r(3):c[2] // registerVal3:NormaliseXY
	local registerVal4 = registerVal3:NormaliseXY()
	-- r(5) = r(0).field(3) // arg0.Cursor
	-- r(5) = r(5).field(4) // arg0.Cursor.Entity
	-- r(5) = r(5):c[5] // arg0.Cursor.Entity:GetPos
	local registerVal5 = arg0.Cursor.Entity:GetPos()
	-- r(6) = r(0):c[6] // arg0:RestrictCursorMovement
	-- r(8) = r(1) // arg1
	-- r(9) = r(3) // registerVal3
	-- r(10) = r(5) // registerVal5
	-- r(11) = false
	local registerVal6 = arg0:RestrictCursorMovement(arg1, registerVal3, registerVal5, false)
	-- r(7) = r(6):c[7] // registerVal6:GetLength
	local registerVal7 = registerVal6:GetLength()
	if 0.000000 < registerVal7 then
		-- r(7) = nil
		-- r(8) = r(0).field(9) // arg0.KeyboardScrolling
		if not arg0.KeyboardScrolling then
			-- r(8) = r(0):c[10] // arg0:MoveCameraBasedOnCursor
			-- r(10) = r(1) // arg1
			-- r(11) = r(6) // registerVal6
			arg0:MoveCameraBasedOnCursor(arg1, registerVal6)
			-- r(8) = r(0).field(3) // arg0.Cursor
			-- r(8) = r(8).field(4) // arg0.Cursor.Entity
			-- r(8) = r(8):c[5] // arg0.Cursor.Entity:GetPos
			local registerVal8 = arg0.Cursor.Entity:GetPos()
			-- skip the next [14] opcodes // advance 14 lines
		else
			-- r(8) = r(0).field(9) // arg0.KeyboardScrolling
			if arg0.KeyboardScrolling then
				-- r(8) = r(0):c[11] // arg0:KeepCursorOnScreen
				-- r(10) = r(1) // arg1
				-- r(11) = r(6) // registerVal6
				-- r(12) = r(2) // arg2
				registerVal8 = arg0:KeepCursorOnScreen(arg1, registerVal6, arg2)
				-- r(6) = r(8) // registerVal8
				-- r(8) = r(0).field(3) // arg0.Cursor
				-- r(8) = r(8).field(4) // arg0.Cursor.Entity
				-- r(8) = r(8):c[12] // arg0.Cursor.Entity:GetFinalPos
				registerVal8 = arg0.Cursor.Entity:GetFinalPos()
			end
		end
		-- r(8) = r(0).field(13) // arg0.Animate
		-- r(9) = r(0).field(3) // arg0.Cursor
		local registerVal10 = {}
		local registerVal11 = {}
		local registerVal12 = {}
		registerVal12.Position = (registerVal8 + registerVal8)
		registerVal11[0.100000] = registerVal12
		registerVal10.Keyframes = registerVal11
		arg0.Animate(arg0.Cursor, registerVal10)
		-- r(8) = r(0).field(17) // arg0.IsSoundCategoryPlaying
		-- r(9) = c[18] // "CursorMove"
		registerVal8 = arg0.IsSoundCategoryPlaying("CursorMove")
		if not registerVal8 then
			-- r(8) = r(0).field(19) // arg0.State
			-- r(9) = g[20] // EWorldMapState
			-- r(9) = r(9).field(21) // EWorldMapState.MAP_STATE_MOVING_FAMILY
			if arg0.State == EWorldMapState.MAP_STATE_MOVING_FAMILY then
				-- r(8) = r(0).field(22) // arg0.PlaySoundWithCategory
				-- r(9) = c[23] // "SE_GUI_MAP_FAMILY_MOVE"
				-- r(10) = c[18] // "CursorMove"
				arg0.PlaySoundWithCategory("SE_GUI_MAP_FAMILY_MOVE", "CursorMove")
				-- skip the next [4] opcodes // advance 4 lines
			else
				-- r(8) = r(0).field(22) // arg0.PlaySoundWithCategory
				-- r(9) = c[24] // "SE_GUI_MAGNIFYING_GLASS_MOVE"
				-- r(10) = c[18] // "CursorMove"
				arg0.PlaySoundWithCategory("SE_GUI_MAGNIFYING_GLASS_MOVE", "CursorMove")
			end
		end
		arg0.FramesSinceLastMoved = 0.000000
	end
	-- r(7) = g[27] // CVector3
	-- r(8) = c[8] // 0.000000
	-- r(9) = c[8] // 0.000000
	-- r(10) = c[8] // 0.000000
	registerVal7 = CVector3(0.000000, 0.000000, 0.000000)
	arg0.MouseMove = registerVal7
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x182
	-- Constant Count: 0x52
	-- Registers Count: 0x16
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.MoveAround(arg0, arg1)
	-- r(2) = r(0).field(0) // arg0.CurrentMode
	-- r(2) = r(2).field(1) // arg0.CurrentMode.MovementMultiplier
	-- skip the next [243] opcodes // advance 243 lines
	-- r(2) = r(0).field(2) // arg0.Camera
	-- r(2) = r(2).field(3) // arg0.Camera.GetFacing
	local registerVal2 = arg0.Camera.GetFacing()
	-- r(3) = r(2):c[4] // registerVal2:NormaliseXY
	local registerVal3 = registerVal2:NormaliseXY()
	if arg0.CurrentMode.MovementMultiplier and 0.000000 < registerVal3 then
		-- r(4) = r(0).field(6) // arg0.Cursor
		-- r(4) = r(4).field(7) // arg0.Cursor.Entity
		-- r(4) = r(4):c[8] // arg0.Cursor.Entity:GetPos
		local registerVal4 = arg0.Cursor.Entity:GetPos()
		arg0.InBounds = true
		arg0.OutOfBoundsRatio = 1.000000
		-- r(5) = r(0).field(13) // arg0.BoundsMarkers
		-- skip the next [34] opcodes // advance 34 lines
		-- r(5) = r(0).field(13) // arg0.BoundsMarkers
		-- skip the next [30] opcodes // advance 30 lines
		arg0.InBounds = false
		arg0.OutOfBoundsRatio = 100.000000
		-- r(5) = g[16] // ipairs
		-- r(6) = r(0).field(13) // arg0.BoundsMarkers
		local registerVal5, registerVal6, registerVal7 = ipairs(arg0.BoundsMarkers)
		for index8,value9 in registerVal5, registerVal6, registerVal7 do
			-- skip the next [22] opcodes // advance 22 lines
			-- r(10) = r(9).field(17) // value9.Position
			-- r(11) = r(10):c[18] // (value9.Position - registerVal4):GetLengthXY
			local registerVal11 = (value9.Position - registerVal4):GetLengthXY()
			-- r(12) = r(9).field(19) // value9.Radius
			if registerVal11 < value9.Radius then
				arg0.InBounds = true
				arg0.OutOfBoundsRatio = 1.000000
				-- skip the next [14] opcodes // advance 14 lines
				-- skip the next [11] opcodes // advance 11 lines
			else
				-- r(12) = r(9).field(19) // value9.Radius
				-- skip the next [8] opcodes // advance 8 lines
				-- r(12) = r(9).field(19) // value9.Radius
				-- r(13) = r(0).field(11) // arg0.OutOfBoundsRatio
				if 0.000000 < value9.Radius and (registerVal11 / value9.Radius) < arg0.OutOfBoundsRatio then
					arg0.OutOfBoundsRatio = (registerVal11 / value9.Radius)
					-- r(13) = r(9).field(17) // value9.Position
					arg0.ClosestOutOfBoundsPosition = value9.Position
				end
			end
			-- skip the next [-24] opcodes // advance -24 lines
		end
		-- r(5) = r(0):c[21] // arg0:RestrictCursorMovement
		-- r(7) = r(1) // arg1
		-- r(8) = r(2) // registerVal2
		-- r(9) = r(4) // registerVal4
		registerVal5 = arg0:RestrictCursorMovement(arg1, registerVal2, registerVal4)
		-- r(6) = r(0).field(6) // arg0.Cursor
		-- r(6) = r(6).field(7) // arg0.Cursor.Entity
		-- r(6) = r(6):c[8] // arg0.Cursor.Entity:GetPos
		registerVal6 = arg0.Cursor.Entity:GetPos()
		-- r(7) = g[23] // CVector3
		-- r(8) = c[5] // 0.000000
		-- r(9) = c[5] // 0.000000
		-- r(10) = c[5] // 0.000000
		registerVal7 = CVector3(0.000000, 0.000000, 0.000000)
		arg0.ControlDirection = registerVal7
		-- r(7) = r(0).field(24) // arg0.ControllerInput
		if arg0.ControllerInput then
			-- r(7) = r(5):c[25] // registerVal5:GetLength
			registerVal7 = registerVal5:GetLength()
			if 0.000000 < registerVal7 then
				-- r(7) = r(0).field(26) // arg0.Animate
				-- r(8) = r(0).field(6) // arg0.Cursor
				local registerVal9 = {}
				local registerVal10 = {}
				registerVal11 = {}
				registerVal11.Position = (registerVal6 + registerVal5)
				registerVal10[0.100000] = registerVal11
				registerVal9.Keyframes = registerVal10
				arg0.Animate(arg0.Cursor, registerVal9)
				-- r(7) = r(0).field(29) // arg0.IsSoundCategoryPlaying
				-- r(8) = c[30] // "CursorMove"
				registerVal7 = arg0.IsSoundCategoryPlaying("CursorMove")
				if not registerVal7 then
					-- r(7) = r(0).field(31) // arg0.State
					-- r(8) = g[32] // EWorldMapState
					-- r(8) = r(8).field(33) // EWorldMapState.MAP_STATE_MOVING_FAMILY
					if arg0.State == EWorldMapState.MAP_STATE_MOVING_FAMILY then
						-- r(7) = r(0).field(34) // arg0.PlaySoundWithCategory
						-- r(8) = c[35] // "SE_GUI_MAP_FAMILY_MOVE"
						-- r(9) = c[30] // "CursorMove"
						arg0.PlaySoundWithCategory("SE_GUI_MAP_FAMILY_MOVE", "CursorMove")
						-- skip the next [4] opcodes // advance 4 lines
					else
						-- r(7) = r(0).field(34) // arg0.PlaySoundWithCategory
						-- r(8) = c[36] // "SE_GUI_MAGNIFYING_GLASS_MOVE"
						-- r(9) = c[30] // "CursorMove"
						arg0.PlaySoundWithCategory("SE_GUI_MAGNIFYING_GLASS_MOVE", "CursorMove")
					end
				end
				arg0.FramesSinceLastMoved = 0.000000
				-- skip the next [117] opcodes // advance 117 lines
			else
				-- r(7) = r(0).field(38) // arg0.StopSoundCategoryPlaying
				-- r(8) = c[30] // "CursorMove"
				arg0.StopSoundCategoryPlaying("CursorMove")
				-- r(7) = r(0).field(37) // arg0.FramesSinceLastMoved
				if arg0.FramesSinceLastMoved == nil then
					arg0.FramesSinceLastMoved = 0.000000
				end
				-- r(7) = r(0).field(37) // arg0.FramesSinceLastMoved
				arg0.FramesSinceLastMoved = (arg0.FramesSinceLastMoved + 1.000000)
				-- r(7) = r(0).field(40) // arg0.WaitForCursor
				if arg0.WaitForCursor then
					-- r(7) = r(0).field(6) // arg0.Cursor
					-- r(7) = r(7).field(7) // arg0.Cursor.Entity
					-- r(7) = r(7):c[41] // arg0.Cursor.Entity:GetFinalPos
					registerVal7 = arg0.Cursor.Entity:GetFinalPos()
					-- r(6) = r(7) // registerVal7
					-- skip the next [98] opcodes // advance 98 lines
				else
					-- r(7) = r(0).field(42) // arg0.MouseMove
					-- r(8) = g[23] // CVector3
					-- r(9) = c[5] // 0.000000
					-- r(10) = c[5] // 0.000000
					-- r(11) = c[5] // 0.000000
					local registerVal8 = CVector3(0.000000, 0.000000, 0.000000)
					if arg0.MouseMove ~= registerVal8 then
						-- r(7) = r(0).field(43) // arg0.KeyboardScrolling
						-- skip the next [87] opcodes // advance 87 lines
						-- r(7) = r(0).field(44) // arg0.InputIgnoreCountdown
						-- skip the next [84] opcodes // advance 84 lines
						-- r(7) = r(0):c[45] // arg0:MoveCursor
						-- r(9) = r(0).field(42) // arg0.MouseMove
						arg0:MoveCursor(arg0.MouseMove)
						-- skip the next [80] opcodes // advance 80 lines
						-- r(7) = r(0).field(43) // arg0.KeyboardScrolling
						-- skip the next [77] opcodes // advance 77 lines
						-- r(7) = r(0).field(44) // arg0.InputIgnoreCountdown
						-- skip the next [74] opcodes // advance 74 lines
						-- r(7) = r(0).field(2) // arg0.Camera
						-- r(7) = r(7).field(8) // arg0.Camera.GetPos
						-- r(8) = r(0).field(6) // arg0.Cursor
						-- r(8) = r(8).field(7) // arg0.Cursor.Entity
						-- r(8) = r(8):c[8] // arg0.Cursor.Entity:GetPos
						registerVal7 = arg0.Camera.GetPos(arg0.Cursor.Entity:GetPos())
						-- r(8) = r(0).field(2) // arg0.Camera
						-- r(8) = r(8).field(46) // arg0.Camera.GetNextPos
						-- r(9) = r(0).field(6) // arg0.Cursor
						-- r(9) = r(9).field(7) // arg0.Cursor.Entity
						-- r(9) = r(9):c[8] // arg0.Cursor.Entity:GetPos
						registerVal8 = arg0.Camera.GetNextPos(arg0.Cursor.Entity:GetPos())
						-- r(10) = c[47] // -0.050000
						-- r(11) = c[48] // 0.050000
						-- r(12) = g[23] // CVector3
						-- r(13) = r(0).field(2) // arg0.Camera
						-- r(13) = r(13).field(49) // arg0.Camera.GetUp
						local registerVal13 = arg0.Camera.GetUp()
						-- r(13) = r(13):c[50] // registerVal13:GetX
						registerVal13 = registerVal13:GetX()
						-- r(14) = r(0).field(2) // arg0.Camera
						-- r(14) = r(14).field(49) // arg0.Camera.GetUp
						local registerVal14 = arg0.Camera.GetUp()
						-- r(14) = r(14):c[51] // registerVal14:GetY
						registerVal14 = registerVal14:GetY()
						-- r(15) = c[5] // 0.000000
						local registerVal12 = CVector3(registerVal13, registerVal14, 0.000000)
						-- r(13) = r(12):c[4] // registerVal12:NormaliseXY
						registerVal12:NormaliseXY()
						-- r(13) = r(9):c[52] // (registerVal7 - registerVal8):GetDot
						-- r(15) = r(12) // registerVal12
						registerVal13 = (registerVal7 - registerVal8):GetDot(registerVal12)
						-- r(14) = r(0).field(2) // arg0.Camera
						-- r(14) = r(14).field(49) // arg0.Camera.GetUp
						registerVal14 = arg0.Camera.GetUp()
						-- r(14) = r(14):c[53] // registerVal14:GetCross
						-- r(16) = g[23] // CVector3
						-- r(17) = c[5] // 0.000000
						-- r(18) = c[5] // 0.000000
						-- r(19) = c[12] // 1.000000
						registerVal14 = registerVal14:GetCross(CVector3(0.000000, 0.000000, 1.000000))
						-- r(15) = g[23] // CVector3
						-- r(16) = r(14):c[50] // registerVal14:GetX
						local registerVal16 = registerVal14:GetX()
						-- r(17) = r(14):c[51] // registerVal14:GetY
						local registerVal17 = registerVal14:GetY()
						-- r(18) = c[5] // 0.000000
						local registerVal15 = CVector3(registerVal16, registerVal17, 0.000000)
						-- r(14) = r(15) // registerVal15
						-- r(15) = r(14):c[4] // registerVal15:NormaliseXY
						registerVal15:NormaliseXY()
						-- r(15) = r(9):c[52] // (registerVal7 - registerVal8):GetDot
						-- r(17) = r(14) // registerVal15
						registerVal15 = (registerVal7 - registerVal8):GetDot(registerVal15)
						-- r(16) = r(9):c[50] // (registerVal7 - registerVal8):GetX
						registerVal16 = (registerVal7 - registerVal8):GetX()
						-- skip the next [12] opcodes // advance 12 lines
						-- r(16) = r(9):c[50] // (registerVal7 - registerVal8):GetX
						registerVal16 = (registerVal7 - registerVal8):GetX()
						-- skip the next [8] opcodes // advance 8 lines
						-- r(16) = r(9):c[51] // (registerVal7 - registerVal8):GetY
						registerVal16 = (registerVal7 - registerVal8):GetY()
						-- skip the next [4] opcodes // advance 4 lines
						-- r(16) = r(9):c[51] // (registerVal7 - registerVal8):GetY
						registerVal16 = (registerVal7 - registerVal8):GetY()
						if not arg0.KeyboardScrolling and arg0.InputIgnoreCountdown == 0.000000 and not arg0.KeyboardScrolling and arg0.InputIgnoreCountdown == 0.000000 and 0.050000 >= registerVal16 and registerVal16 >= -0.050000 and 0.050000 < registerVal16 or registerVal16 < -0.050000 then
							-- r(7) = r(0).field(37) // arg0.FramesSinceLastMoved
							if arg0.FramesSinceLastMoved < 20.000000 then
								-- r(7) = r(0).field(55) // arg0.CursorAndScrollingLinked
								if arg0.CursorAndScrollingLinked then
									arg0.FocusPosition = registerVal7
								end
								-- r(7) = r(0).field(57) // arg0.InTransitionAnimation
								-- skip the next [6] opcodes // advance 6 lines
								-- r(7) = r(0).field(2) // arg0.Camera
								-- r(7) = r(7):c[58] // arg0.Camera:IsAnimating
								registerVal7 = arg0.Camera:IsAnimating()
								if arg0.InTransitionAnimation and registerVal7 == false then
									arg0.InTransitionAnimation = false
								end
								-- r(7) = r(0).field(57) // arg0.InTransitionAnimation
								if arg0.InTransitionAnimation == false then
									-- r(7) = r(0):c[59] // arg0:FocusOn
									-- r(9) = r(0).field(56) // arg0.FocusPosition
									-- r(10) = c[60] // 0.600000
									arg0:FocusOn(arg0.FocusPosition, 0.600000)
								end
							end
						end
						-- r(2) = r(0).field(2) // arg0.Camera
						-- r(2) = r(2).field(46) // arg0.Camera.GetNextPos
						-- r(3) = r(0).field(6) // arg0.Cursor
						-- r(3) = r(3).field(7) // arg0.Cursor.Entity
						-- r(3) = r(3):c[8] // arg0.Cursor.Entity:GetPos
						registerVal2 = arg0.Camera.GetNextPos(arg0.Cursor.Entity:GetPos())
						-- r(3) = r(0).field(6) // arg0.Cursor
						-- r(3) = r(3).field(7) // arg0.Cursor.Entity
						-- r(3) = r(3):c[46] // arg0.Cursor.Entity:GetNextPos
						registerVal3 = arg0.Cursor.Entity:GetNextPos()
						-- r(5) = r(4):c[61] // (registerVal3 - registerVal2):Normalise
						(registerVal3 - registerVal2):Normalise()
						-- r(5) = nil
						-- r(6) = c[5] // 0.000000
						-- r(7) = c[12] // 1.000000
						-- r(8) = r(0).field(6) // arg0.Cursor
						-- r(8) = r(8).field(62) // arg0.Cursor.IsMesh
						if arg0.Cursor.IsMesh then
							-- r(8) = r(0).field(0) // arg0.CurrentMode
							-- r(8) = r(8).field(63) // arg0.CurrentMode.CursorDistFromCamera
							-- skip the next [9] opcodes // advance 9 lines
						else
							-- r(8) = r(0).field(6) // arg0.Cursor
							-- r(8) = r(8).field(64) // arg0.Cursor.IsSprite
							if arg0.Cursor.IsSprite then
								-- r(5) = r(3) // registerVal3
								-- r(8) = r(0).field(0) // arg0.CurrentMode
								-- r(6) = r(8).field(65) // arg0.CurrentMode.SpriteTimeFrameAddition
								-- r(8) = r(0).field(0) // arg0.CurrentMode
								-- r(7) = r(8).field(66) // arg0.CurrentMode.SpriteScaleMultiply
							end
						end
						-- r(8) = r(0).field(67) // arg0.AutomaticCursorUpdateSpeed
						if not arg0.AutomaticCursorUpdateSpeed then
							-- r(8) = r(0).field(0) // arg0.CurrentMode
							-- r(8) = r(8).field(68) // arg0.CurrentMode.CursorGraphicMovementTime
						end
						-- r(9) = r(0).field(0) // arg0.CurrentMode
						-- r(9) = r(9).field(69) // arg0.CurrentMode.CursorGraphic
						-- r(9) = r(9).field(70) // arg0.CurrentMode.CursorGraphic.Scale
						-- r(10) = g[23] // CVector3
						-- r(11) = c[5] // 0.000000
						-- r(12) = c[5] // 0.000000
						-- r(13) = c[5] // 0.000000
						registerVal10 = CVector3(0.000000, 0.000000, 0.000000)
						-- r(11) = r(0).field(2) // arg0.Camera
						-- r(11) = r(11).field(3) // arg0.Camera.GetFacing
						registerVal11 = arg0.Camera.GetFacing()
						-- r(11) = r(0).field(0) // arg0.CurrentMode
						-- r(11) = r(11).field(69) // arg0.CurrentMode.CursorGraphic
						-- r(11) = r(11).field(71) // arg0.CurrentMode.CursorGraphic.Colour
						-- r(12) = r(0).field(2) // arg0.Camera
						-- r(12) = r(12).field(49) // arg0.Camera.GetUp
						registerVal12 = arg0.Camera.GetUp()
						registerVal13 = {}
						registerVal14 = {}
						registerVal15 = {}
						registerVal15.Position = registerVal3
						registerVal15.Scale = (arg0.CurrentMode.CursorGraphic.Scale * arg0.CurrentMode.SpriteScaleMultiply)
						registerVal15.Colour = arg0.CurrentMode.CursorGraphic.Colour
						registerVal14[(arg0.CurrentMode.CursorGraphicMovementTime + arg0.CurrentMode.SpriteTimeFrameAddition)] = registerVal15
						registerVal13.Keyframes = registerVal14
						-- r(14) = r(0).field(0) // arg0.CurrentMode
						-- r(14) = r(14).field(72) // arg0.CurrentMode.TiltCursor
						if arg0.CurrentMode.TiltCursor then
							-- r(14) = r(13).field(27) // registerVal13.Keyframes
							-- r(14) = r(14)[r(8)] // registerVal13.Keyframes[(arg0.CurrentMode.CursorGraphicMovementTime + arg0.CurrentMode.SpriteTimeFrameAddition)]
							-- r(15) = r(0):c[72] // arg0:TiltCursor
							-- r(17) = r(10) // (registerVal10 - registerVal11)
							-- r(18) = r(12) // registerVal12
							-- r(19) = r(1) // arg1
							registerVal15 = arg0:TiltCursor((registerVal10 - registerVal11), registerVal12, arg1)
							registerVal13.Keyframes[(arg0.CurrentMode.CursorGraphicMovementTime + arg0.CurrentMode.SpriteTimeFrameAddition)].Orientation = registerVal15
							-- skip the next [7] opcodes // advance 7 lines
						else
							-- r(14) = r(13).field(27) // registerVal13.Keyframes
							-- r(14) = r(14)[r(8)] // registerVal13.Keyframes[(arg0.CurrentMode.CursorGraphicMovementTime + arg0.CurrentMode.SpriteTimeFrameAddition)]
							-- r(15) = g[74] // COrientation
							-- r(16) = r(10) // (registerVal10 - registerVal11)
							-- r(17) = r(12) // registerVal12
							registerVal15 = COrientation((registerVal10 - registerVal11), registerVal12)
							registerVal13.Keyframes[(arg0.CurrentMode.CursorGraphicMovementTime + arg0.CurrentMode.SpriteTimeFrameAddition)].Orientation = registerVal15
						end
						if registerVal3 then
							-- r(14) = r(0):c[75] // arg0:AnimateCursorGraphic
							-- r(16) = r(13) // registerVal13
							arg0:AnimateCursorGraphic(registerVal13)
						end
						-- r(14) = g[23] // CVector3
						-- r(15) = c[5] // 0.000000
						-- r(16) = c[5] // 0.000000
						-- r(17) = c[12] // 1.000000
						registerVal14 = CVector3(0.000000, 0.000000, 1.000000)
						-- r(15) = r(0).field(0) // arg0.CurrentMode
						-- r(15) = r(15).field(76) // arg0.CurrentMode.CursorLightDistFromGround
						-- r(16) = r(0):c[77] // arg0:GetDistFromCursorForLight
						registerVal16 = arg0:GetDistFromCursorForLight()
						-- r(18) = r(13).field(27) // registerVal13.Keyframes
						-- r(18) = r(18)[r(8)] // registerVal13.Keyframes[(arg0.CurrentMode.CursorGraphicMovementTime + arg0.CurrentMode.SpriteTimeFrameAddition)]
						registerVal13.Keyframes[(arg0.CurrentMode.CursorGraphicMovementTime + arg0.CurrentMode.SpriteTimeFrameAddition)].Position = ((registerVal3 + (registerVal14 * arg0.CurrentMode.CursorLightDistFromGround)) + ((registerVal3 - registerVal2) * -registerVal16))
						-- r(18) = r(0).field(26) // arg0.Animate
						-- r(19) = r(0).field(78) // arg0.CursorLight
						-- r(20) = r(13) // registerVal13
						arg0.Animate(arg0.CursorLight, registerVal13)
						-- r(18) = nil
						-- r(19) = r(0).field(31) // arg0.State
						-- r(20) = g[32] // EWorldMapState
						-- r(20) = r(20).field(33) // EWorldMapState.MAP_STATE_MOVING_FAMILY
						if arg0.State == EWorldMapState.MAP_STATE_MOVING_FAMILY then
							-- r(18) = r(0).field(79) // arg0.MovingFamilyLightDistance
							-- skip the next [1] opcodes // advance 1 lines
						else
							-- r(18) = r(0).field(80) // arg0.TestDist
						end
						if registerVal3 ~= nil then
							-- skip the next [2] opcodes // advance 2 lines
						else
						end
						-- r(19) = r(13).field(27) // registerVal13.Keyframes
						-- r(19) = r(19)[r(8)] // registerVal13.Keyframes[(arg0.CurrentMode.CursorGraphicMovementTime + arg0.CurrentMode.SpriteTimeFrameAddition)]
						registerVal13.Keyframes[(arg0.CurrentMode.CursorGraphicMovementTime + arg0.CurrentMode.SpriteTimeFrameAddition)].Position = ((registerVal3 + ((registerVal3 - registerVal2) * arg0.TestDist)) + ((registerVal3 - registerVal2) * arg0.TestDist))
						-- r(19) = r(0).field(26) // arg0.Animate
						-- r(20) = r(0).field(81) // arg0.CursorLight2
						-- r(21) = r(13) // registerVal13
						arg0.Animate(arg0.CursorLight2, registerVal13)
						arg0.KeyboardScrolling = false
						-- return
					end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x5F
	-- Constant Count: 0x10
	-- Registers Count: 0xF
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.TiltCursor(arg0, arg1, arg2, arg3)
	-- r(4) = r(0).field(0) // arg0.CurrentMode
	-- r(4) = r(4).field(1) // arg0.CurrentMode.CursorRotateAngle
	if not arg0.CurrentMode.CursorRotateAngle then
		-- r(4) = c[2] // 20.000000
	end
	-- r(5) = r(3):c[3] // arg3:GetY
	local registerVal5 = arg3:GetY()
	-- r(6) = r(3):c[4] // arg3:GetX
	local registerVal6 = arg3:GetX()
	-- r(7) = g[5] // CVector3
	-- r(8) = r(1):c[3] // arg1:GetY
	local registerVal8 = arg1:GetY()
	-- r(9) = r(2):c[6] // arg2:GetZ
	local registerVal9 = arg2:GetZ()
	-- r(9) = r(1):c[6] // arg1:GetZ
	registerVal9 = arg1:GetZ()
	-- r(10) = r(2):c[3] // arg2:GetY
	local registerVal10 = arg2:GetY()
	-- r(9) = r(1):c[6] // arg1:GetZ
	registerVal9 = arg1:GetZ()
	-- r(10) = r(2):c[4] // arg2:GetX
	registerVal10 = arg2:GetX()
	-- r(10) = r(1):c[4] // arg1:GetX
	registerVal10 = arg1:GetX()
	-- r(11) = r(2):c[6] // arg2:GetZ
	local registerVal11 = arg2:GetZ()
	-- r(10) = r(1):c[4] // arg1:GetX
	registerVal10 = arg1:GetX()
	-- r(11) = r(2):c[3] // arg2:GetY
	registerVal11 = arg2:GetY()
	-- r(11) = r(1):c[3] // arg1:GetY
	registerVal11 = arg1:GetY()
	-- r(12) = r(2):c[4] // arg2:GetX
	local registerVal12 = arg2:GetX()
	local registerVal7 = CVector3(((registerVal8 * registerVal9) - (registerVal9 * registerVal10)), ((registerVal9 * registerVal10) - (registerVal10 * registerVal11)), ((registerVal10 * registerVal11) - (registerVal11 * registerVal12)))
	-- r(8) = r(7):c[7] // registerVal7:Normalise
	registerVal7:Normalise()
	-- r(8 to 9) inclusive = nil
	-- r(10) = r(1):c[8] // arg1:RotateAroundDirectionByAngle
	-- r(12) = r(7) // registerVal7
	-- r(13) = r(5) // (20.000000 * registerVal5)
	arg1:RotateAroundDirectionByAngle(registerVal7, (20.000000 * registerVal5))
	-- r(10) = r(1):c[8] // arg1:RotateAroundDirectionByAngle
	-- r(12) = r(2) // arg2
	-- r(13) = r(6) // (20.000000 * registerVal6)
	arg1:RotateAroundDirectionByAngle(arg2, (20.000000 * registerVal6))
	-- r(10) = r(0).field(9) // arg0.Cursor
	-- r(10) = r(10).field(10) // arg0.Cursor.Facing
	if arg0.Cursor.Facing then
		-- r(10) = g[11] // WorldMap
		-- r(10) = r(10):c[12] // WorldMap:InterpolateRotation
		-- r(12) = r(0).field(9) // arg0.Cursor
		-- r(12) = r(12).field(10) // arg0.Cursor.Facing
		-- r(13) = r(1) // arg1
		-- r(14) = c[13] // 0.100000
		registerVal10 = WorldMap:InterpolateRotation(arg0.Cursor.Facing, arg1, 0.100000)
		-- r(8) = r(10) // registerVal10
		-- r(10) = g[11] // WorldMap
		-- r(10) = r(10):c[12] // WorldMap:InterpolateRotation
		-- r(12) = r(0).field(9) // arg0.Cursor
		-- r(12) = r(12).field(14) // arg0.Cursor.Up
		-- r(13) = r(2) // arg2
		-- r(14) = c[13] // 0.100000
		registerVal10 = WorldMap:InterpolateRotation(arg0.Cursor.Up, arg2, 0.100000)
		-- r(9) = r(10) // registerVal10
	end
	-- r(10) = r(0).field(9) // arg0.Cursor
	-- r(11) = (registerVal10 or registerVal10)
	-- skip the next [1] opcodes // advance 1 lines
	-- r(11) = r(1) // arg1
	arg0.Cursor.Facing = arg1
	-- r(10) = r(0).field(9) // arg0.Cursor
	-- r(11) = (registerVal10 or arg0.Cursor)
	-- skip the next [1] opcodes // advance 1 lines
	-- r(11) = r(2) // arg2
	arg0.Cursor.Up = arg2
	-- r(10) = g[15] // COrientation
	-- r(11) = r(0).field(9) // arg0.Cursor
	-- r(11) = r(11).field(10) // arg0.Cursor.Facing
	-- r(12) = r(0).field(9) // arg0.Cursor
	-- r(12) = r(12).field(14) // arg0.Cursor.Up
	return COrientation(arg0.Cursor.Facing, arg0.Cursor.Up)
	-- return
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x1F
	-- Constant Count: 0x4
	-- Registers Count: 0xF
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.InterpolateRotation(arg0, arg1, arg2, arg3)
	-- r(4) = r(2):c[0] // arg2:GetX
	local registerVal4 = arg2:GetX()
	-- r(5) = r(1):c[0] // arg1:GetX
	local registerVal5 = arg1:GetX()
	-- r(5) = r(2):c[1] // arg2:GetY
	registerVal5 = arg2:GetY()
	-- r(6) = r(1):c[1] // arg1:GetY
	local registerVal6 = arg1:GetY()
	-- r(6) = r(2):c[2] // arg2:GetZ
	registerVal6 = arg2:GetZ()
	-- r(7) = r(1):c[2] // arg1:GetZ
	local registerVal7 = arg1:GetZ()
	-- r(10) = g[3] // CVector3
	-- r(11) = r(1):c[0] // arg1:GetX
	local registerVal11 = arg1:GetX()
	-- r(12) = r(1):c[1] // arg1:GetY
	local registerVal12 = arg1:GetY()
	-- r(13) = r(1):c[2] // arg1:GetZ
	local registerVal13 = arg1:GetZ()
	return CVector3((registerVal11 + ((registerVal4 - registerVal5) * arg3)), (registerVal12 + ((registerVal5 - registerVal6) * arg3)), (registerVal13 + ((registerVal6 - registerVal7) * arg3)))
	-- return
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x129
	-- Constant Count: 0x51
	-- Registers Count: 0xA
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.ZoomIn(arg0)
	-- r(1) = r(0).field(0) // arg0.IsValidZoomTarget
	-- r(2) = r(0).field(1) // arg0.Target
	local registerVal1 = arg0.IsValidZoomTarget(arg0.Target)
	if registerVal1 then
		-- r(1) = g[3] // CVector3
		-- r(2) = c[4] // 0.000000
		-- r(3) = c[4] // 0.000000
		-- r(4) = c[4] // 0.000000
		registerVal1 = CVector3(0.000000, 0.000000, 0.000000)
		arg0.ControlDirection = registerVal1
		-- r(1) = nil
		-- r(2) = r(0).field(1) // arg0.Target
		-- r(2) = r(2).field(5) // arg0.Target.RegionInfo
		-- skip the next [12] opcodes // advance 12 lines
		-- r(2) = r(0).field(1) // arg0.Target
		-- r(2) = r(2).field(5) // arg0.Target.RegionInfo
		-- r(2) = r(2).field(6) // arg0.Target.RegionInfo.GameLevel
		if arg0.Target.RegionInfo and arg0.Target.RegionInfo.GameLevel then
			-- r(2) = g[7] // string
			-- r(2) = r(2).field(8) // string.lower
			-- r(3) = r(0).field(1) // arg0.Target
			-- r(3) = r(3).field(5) // arg0.Target.RegionInfo
			-- r(3) = r(3).field(6) // arg0.Target.RegionInfo.GameLevel
			local registerVal2 = string.lower(arg0.Target.RegionInfo.GameLevel)
			-- r(1) = r(2) // registerVal2
		end
		-- r(2) = r(0).field(9) // arg0.SelectionMode
		-- skip the next [12] opcodes // advance 12 lines
		-- r(2) = r(0).field(10) // arg0.State
		-- r(3) = g[11] // EWorldMapState
		-- r(3) = r(3).field(12) // EWorldMapState.MAP_STATE_SPECTATOR_MODE
		-- skip the next [7] opcodes // advance 7 lines
		-- r(2) = r(0).field(1) // arg0.Target
		-- r(2) = r(2).field(13) // arg0.Target.EntityID
		if arg0.SelectionMode and arg0.State == EWorldMapState.MAP_STATE_SPECTATOR_MODE and arg0.Target.EntityID then
			-- r(2) = false
			return false
			-- skip the next [253] opcodes // advance 253 lines
		else
			-- r(2) = r(0).field(9) // arg0.SelectionMode
			-- skip the next [109] opcodes // advance 109 lines
			-- r(2) = r(0).field(1) // arg0.Target
			-- r(2) = r(2).field(13) // arg0.Target.EntityID
			if arg0.SelectionMode and arg0.Target.EntityID then
				-- r(2) = r(0).field(14) // arg0.Properties
				-- r(3) = r(0).field(1) // arg0.Target
				-- r(3) = r(3).field(13) // arg0.Target.EntityID
				-- r(2) = r(2)[r(3)] // arg0.Properties[arg0.Target.EntityID]
				if not arg0.Properties[arg0.Target.EntityID] then
					-- r(2) = g[15] // PlayerProperties
					-- r(2) = r(2).field(16) // PlayerProperties.GetTextTag
					-- r(3) = g[17] // GetGameOwningHeroFromGameWorld
					local registerVal3 = GetGameOwningHeroFromGameWorld()
					-- r(4) = r(0).field(1) // arg0.Target
					-- r(4) = r(4).field(13) // arg0.Target.EntityID
					registerVal2 = PlayerProperties.GetTextTag(registerVal3, arg0.Target.EntityID)
					-- r(3) = g[15] // PlayerProperties
					-- r(3) = r(3).field(18) // PlayerProperties.GetBuyPriceFromString
					-- r(4) = g[17] // GetGameOwningHeroFromGameWorld
					local registerVal4 = GetGameOwningHeroFromGameWorld()
					-- r(5) = r(0).field(1) // arg0.Target
					-- r(5) = r(5).field(13) // arg0.Target.EntityID
					registerVal3 = PlayerProperties.GetBuyPriceFromString(registerVal4, arg0.Target.EntityID)
					-- r(4) = r(0).field(19) // arg0.SelectionModeType
					-- r(5) = g[20] // WorldMap
					-- r(5) = r(5).field(21) // WorldMap.SelectionModeTypeEnum
					-- r(5) = r(5).field(22) // WorldMap.SelectionModeTypeEnum.MARRIAGE
					if arg0.SelectionModeType == WorldMap.SelectionModeTypeEnum.MARRIAGE then
						-- r(4) = r(0):c[23] // arg0:AskQuestion
						-- r(6) = c[24] // "TEXT_GUI_SELECT_MARITAL_HOME_BUY_CONFIRMATION"
						-- r(7) = c[25] // "UseTargetInSelectionMode"
						-- r(8) = r(2) // registerVal2
						-- r(9) = r(3) // registerVal3
						arg0:AskQuestion("TEXT_GUI_SELECT_MARITAL_HOME_BUY_CONFIRMATION", "UseTargetInSelectionMode", registerVal2, registerVal3)
						-- skip the next [69] opcodes // advance 69 lines
					else
						-- r(4) = r(0).field(19) // arg0.SelectionModeType
						-- r(5) = g[20] // WorldMap
						-- r(5) = r(5).field(21) // WorldMap.SelectionModeTypeEnum
						-- r(5) = r(5).field(26) // WorldMap.SelectionModeTypeEnum.ADOPTION
						if arg0.SelectionModeType == WorldMap.SelectionModeTypeEnum.ADOPTION then
							-- r(4) = r(0):c[23] // arg0:AskQuestion
							-- r(6) = c[27] // "TEXT_GUI_SELECT_FAMILY_HOME_ADOPTION_BUY_CONFIRMATION"
							-- r(7) = c[25] // "UseTargetInSelectionMode"
							-- r(8) = r(2) // registerVal2
							-- r(9) = r(3) // registerVal3
							arg0:AskQuestion("TEXT_GUI_SELECT_FAMILY_HOME_ADOPTION_BUY_CONFIRMATION", "UseTargetInSelectionMode", registerVal2, registerVal3)
							-- skip the next [56] opcodes // advance 56 lines
						else
							-- r(2) = r(0).field(14) // arg0.Properties
							-- r(3) = r(0).field(1) // arg0.Target
							-- r(3) = r(3).field(13) // arg0.Target.EntityID
							-- r(2) = r(2)[r(3)] // arg0.Properties[arg0.Target.EntityID]
							-- r(2) = r(2).field(28) // arg0.Properties[arg0.Target.EntityID].is_rental_property
							if arg0.Properties[arg0.Target.EntityID].is_rental_property ~= true then
								-- r(2) = false // skip next opcode
							end
							-- r(2) = true
							-- r(3) = r(0).field(19) // arg0.SelectionModeType
							-- r(4) = g[20] // WorldMap
							-- r(4) = r(4).field(21) // WorldMap.SelectionModeTypeEnum
							-- r(4) = r(4).field(22) // WorldMap.SelectionModeTypeEnum.MARRIAGE
							if arg0.SelectionModeType == WorldMap.SelectionModeTypeEnum.MARRIAGE then
								if true then
									-- r(3) = r(0):c[23] // arg0:AskQuestion
									-- r(5) = c[30] // "TEXT_GUI_SELECT_MARITAL_HOME_EVICT_TENANTS_CONFIRMATION"
									-- r(6) = c[25] // "UseTargetInSelectionMode"
									arg0:AskQuestion("TEXT_GUI_SELECT_MARITAL_HOME_EVICT_TENANTS_CONFIRMATION", "UseTargetInSelectionMode")
									-- skip the next [34] opcodes // advance 34 lines
								else
									-- r(3) = r(0):c[23] // arg0:AskQuestion
									-- r(5) = c[31] // "TEXT_GUI_SELECT_MARITAL_HOME_CONFIRMATION"
									-- r(6) = c[25] // "UseTargetInSelectionMode"
									arg0:AskQuestion("TEXT_GUI_SELECT_MARITAL_HOME_CONFIRMATION", "UseTargetInSelectionMode")
									-- skip the next [29] opcodes // advance 29 lines
								else
									-- r(3) = r(0).field(19) // arg0.SelectionModeType
									-- r(4) = g[20] // WorldMap
									-- r(4) = r(4).field(21) // WorldMap.SelectionModeTypeEnum
									-- r(4) = r(4).field(26) // WorldMap.SelectionModeTypeEnum.ADOPTION
									if arg0.SelectionModeType == WorldMap.SelectionModeTypeEnum.ADOPTION then
										if true then
											-- r(3) = r(0):c[23] // arg0:AskQuestion
											-- r(5) = c[32] // "TEXT_GUI_SELECT_FAMILY_HOME_ADOPTION_EVICT_TENANTS_CONFIRMATION"
											-- r(6) = c[25] // "UseTargetInSelectionMode"
											arg0:AskQuestion("TEXT_GUI_SELECT_FAMILY_HOME_ADOPTION_EVICT_TENANTS_CONFIRMATION", "UseTargetInSelectionMode")
											-- skip the next [16] opcodes // advance 16 lines
										else
											-- r(3) = r(0).field(33) // arg0.CurrentInstance
											-- r(3) = r(3).field(34) // arg0.CurrentInstance.FamilyHomes
											-- r(4) = r(0).field(1) // arg0.Target
											-- r(4) = r(4).field(13) // arg0.Target.EntityID
											-- r(3) = r(3)[r(4)] // arg0.CurrentInstance.FamilyHomes[arg0.Target.EntityID]
											if arg0.CurrentInstance.FamilyHomes[arg0.Target.EntityID] ~= nil then
												-- r(3) = r(0):c[23] // arg0:AskQuestion
												-- r(5) = c[36] // "TEXT_GUI_SELECT_FAMILY_HOME_ADOPTION_FAMILY_CONFIRMATION"
												-- r(6) = c[25] // "UseTargetInSelectionMode"
												arg0:AskQuestion("TEXT_GUI_SELECT_FAMILY_HOME_ADOPTION_FAMILY_CONFIRMATION", "UseTargetInSelectionMode")
												-- skip the next [4] opcodes // advance 4 lines
											else
												-- r(3) = r(0):c[23] // arg0:AskQuestion
												-- r(5) = c[37] // "TEXT_GUI_SELECT_FAMILY_HOME_ADOPTION_EMPTY_CONFIRMATION"
												-- r(6) = c[25] // "UseTargetInSelectionMode"
												arg0:AskQuestion("TEXT_GUI_SELECT_FAMILY_HOME_ADOPTION_EMPTY_CONFIRMATION", "UseTargetInSelectionMode")
											end
										end
									end
								end
							end
						end
					end
				end
				-- r(2) = true
				return true
				-- skip the next [141] opcodes // advance 141 lines
			else
				-- r(2) = r(0):c[38] // arg0:ShouldTeleportToLevelFromRegionView
				-- r(4) = r(1) // registerVal2
				registerVal2 = arg0:ShouldTeleportToLevelFromRegionView(registerVal2)
				if registerVal2 then
					-- r(2) = r(0):c[39] // arg0:PreConditionalTeleport
					-- r(4) = false
					arg0:PreConditionalTeleport(false)
					-- skip the next [132] opcodes // advance 132 lines
				else
					-- r(2) = r(0).field(1) // arg0.Target
					-- r(2) = r(2).field(40) // arg0.Target.FastTravelStop
					if arg0.Target.FastTravelStop then
						-- r(2) = r(0).field(1) // arg0.Target
						-- r(2) = r(2).field(40) // arg0.Target.FastTravelStop
						arg0.FastTravelStop = arg0.Target.FastTravelStop
						-- r(2) = r(0).field(1) // arg0.Target
						-- r(2) = r(2).field(42) // arg0.Target.LevelOverride
						if not arg0.Target.LevelOverride then
							-- r(2) = r(0).field(43) // arg0.CurrentRegion
							-- r(2) = r(2).field(44) // arg0.CurrentRegion.Name
						end
						arg0.FastTravelLevel = arg0.CurrentRegion.Name
						-- r(2) = r(0):c[23] // arg0:AskQuestion
						-- r(4) = c[45] // "Fast travel to "
						-- r(5) = r(0).field(1) // arg0.Target
						-- r(5) = r(5).field(40) // arg0.Target.FastTravelStop
						-- r(6) = c[46] // "?"
						-- r(4) = r(4)..r(5)..r(6) // ("Fast travel to " .. arg0.Target.FastTravelStop .. "?")
						-- r(5) = c[47] // "FastTravelMeDo"
						arg0:AskQuestion(("Fast travel to " .. arg0.Target.FastTravelStop .. "?"), "FastTravelMeDo")
						-- skip the next [109] opcodes // advance 109 lines
					else
						-- r(2) = r(0).field(48) // arg0.CurrentMode
						-- r(2) = r(2).field(49) // arg0.CurrentMode.NextMode
						if arg0.CurrentMode.NextMode then
							-- r(2) = r(0).field(48) // arg0.CurrentMode
							-- r(2) = r(2).field(49) // arg0.CurrentMode.NextMode
							if arg0.CurrentMode.NextMode == "RegionView" then
								-- r(2) = g[51] // MessageEvents
								-- r(2) = r(2).field(52) // MessageEvents.PostMessage
								registerVal3 = {}
								registerVal3.type = "GuiRooms_RoomAboutToChange"
								registerVal3.extra_data = 1.000000
								MessageEvents.PostMessage(registerVal3)
								-- r(2) = r(0).field(57) // arg0.Modes
								-- r(3) = r(0).field(1) // arg0.Target
								arg0.Modes.LastTarget = arg0.Target
							end
							-- r(2) = r(0).field(1) // arg0.Target
							arg0.ZoomTarget = arg0.Target
							-- r(2) = r(0).field(59) // arg0.ZoomTarget
							-- r(2) = r(2).field(5) // arg0.ZoomTarget.RegionInfo
							-- skip the next [11] opcodes // advance 11 lines
							-- r(2) = r(0).field(59) // arg0.ZoomTarget
							-- r(2) = r(2).field(5) // arg0.ZoomTarget.RegionInfo
							-- r(2) = r(2).field(60) // arg0.ZoomTarget.RegionInfo.Function
							if arg0.ZoomTarget.RegionInfo and arg0.ZoomTarget.RegionInfo.Function then
								-- r(2) = r(0).field(59) // arg0.ZoomTarget
								-- r(2) = r(2).field(5) // arg0.ZoomTarget.RegionInfo
								-- r(2) = r(2).field(60) // arg0.ZoomTarget.RegionInfo.Function
								-- r(3) = r(0) // arg0
								arg0.ZoomTarget.RegionInfo.Function(arg0)
								-- skip the next [73] opcodes // advance 73 lines
							else
								-- r(2) = r(0).field(59) // arg0.ZoomTarget
								-- r(2) = r(2).field(5) // arg0.ZoomTarget.RegionInfo
								-- skip the next [10] opcodes // advance 10 lines
								-- r(2) = r(0):c[61] // arg0:CanZoomIntoLevel
								-- r(4) = r(0).field(59) // arg0.ZoomTarget
								-- r(4) = r(4).field(5) // arg0.ZoomTarget.RegionInfo
								registerVal2 = arg0:CanZoomIntoLevel(arg0.ZoomTarget.RegionInfo)
								if arg0.ZoomTarget.RegionInfo and not registerVal2 then
									arg0.ZoomTarget = nil
									-- r(2) = false
									return false
									-- skip the next [59] opcodes // advance 59 lines
								else
									-- r(2) = nil
									-- r(3) = r(0).field(59) // arg0.ZoomTarget
									-- r(3) = r(3).field(5) // arg0.ZoomTarget.RegionInfo
									-- skip the next [19] opcodes // advance 19 lines
									-- r(3) = r(0).field(59) // arg0.ZoomTarget
									-- r(3) = r(3).field(5) // arg0.ZoomTarget.RegionInfo
									-- r(3) = r(3).field(62) // arg0.ZoomTarget.RegionInfo.StartPos
									if arg0.ZoomTarget.RegionInfo and arg0.ZoomTarget.RegionInfo.StartPos then
										-- r(3) = r(0).field(59) // arg0.ZoomTarget
										-- r(3) = r(3).field(5) // arg0.ZoomTarget.RegionInfo
										-- r(3) = r(3).field(63) // arg0.ZoomTarget.RegionInfo.Centre
										-- r(4) = r(0).field(64) // arg0.ModeChangeOverridePosition
										if not arg0.ModeChangeOverridePosition then
											-- r(4) = r(0).field(59) // arg0.ZoomTarget
											-- r(4) = r(4).field(5) // arg0.ZoomTarget.RegionInfo
											-- r(4) = r(4).field(65) // arg0.ZoomTarget.RegionInfo.Offset
											-- r(5) = r(0).field(59) // arg0.ZoomTarget
											-- r(5) = r(5).field(5) // arg0.ZoomTarget.RegionInfo
											-- r(5) = r(5).field(62) // arg0.ZoomTarget.RegionInfo.StartPos
										end
									end
									-- r(3) = g[66] // table
									-- r(3) = r(3).field(67) // table.insert
									-- r(4) = r(0).field(68) // arg0.PreviousModes
									-- r(5) = r(0).field(48) // arg0.CurrentMode
									table.insert(arg0.PreviousModes, arg0.CurrentMode)
									-- r(3) = g[69] // Network
									-- r(3) = r(3).field(70) // Network.IsInLiveGame
									registerVal3 = Network.IsInLiveGame()
									-- skip the next [4] opcodes // advance 4 lines
									-- r(3) = r(0):c[72] // arg0:IsActor
									registerVal3 = arg0:IsActor()
									if registerVal3 == false or registerVal3 then
										-- r(3) = r(0):c[73] // arg0:WrangleNetworkZoom
										-- r(5) = true
										-- r(6) = r(0).field(74) // arg0.Cursor
										-- r(6) = r(6).field(75) // arg0.Cursor.Entity
										-- r(6) = r(6):c[76] // arg0.Cursor.Entity:GetPos
										local registerVal6 = arg0.Cursor.Entity:GetPos()
										-- r(7) = r(0).field(77) // arg0.Camera
										-- r(7) = r(7).field(76) // arg0.Camera.GetPos
										local registerVal7 = arg0.Camera.GetPos()
										-- r(8) = r(0).field(77) // arg0.Camera
										-- r(8) = r(8).field(78) // arg0.Camera.GetOrientation
										arg0:WrangleNetworkZoom(true, registerVal6, registerVal7, arg0.Camera.GetOrientation())
									end
									-- r(3) = r(0):c[79] // arg0:SetMode
									-- r(5) = r(0).field(57) // arg0.Modes
									-- r(6) = r(0).field(48) // arg0.CurrentMode
									-- r(6) = r(6).field(49) // arg0.CurrentMode.NextMode
									-- r(5) = r(5)[r(6)] // arg0.Modes[arg0.CurrentMode.NextMode]
									-- r(6) = c[80] // 0.750000
									-- r(7) = r(2) // (arg0.ZoomTarget.RegionInfo.Centre + (arg0.ZoomTarget.RegionInfo.Offset + arg0.ZoomTarget.RegionInfo.StartPos))
									arg0:SetMode(arg0.Modes[arg0.CurrentMode.NextMode], 0.750000, (arg0.ZoomTarget.RegionInfo.Centre + (arg0.ZoomTarget.RegionInfo.Offset + arg0.ZoomTarget.RegionInfo.StartPos)))
								end
							end
							-- r(2) = true
							return true
						end
					end
				end
			end
		end
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x71
	-- Constant Count: 0x2E
	-- Registers Count: 0x7
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.ZoomOut(arg0)
	-- r(1) = g[0] // Network
	-- r(1) = r(1).field(1) // Network.IsInLiveGame
	local registerVal1 = Network.IsInLiveGame()
	-- skip the next [4] opcodes // advance 4 lines
	-- r(1) = r(0):c[3] // arg0:IsActor
	registerVal1 = arg0:IsActor()
	if registerVal1 == false or registerVal1 then
		-- r(1) = r(0):c[4] // arg0:WrangleNetworkZoom
		-- r(3) = false
		-- r(4) = r(0).field(5) // arg0.Cursor
		-- r(4) = r(4).field(6) // arg0.Cursor.Entity
		-- r(4) = r(4):c[7] // arg0.Cursor.Entity:GetPos
		local registerVal4 = arg0.Cursor.Entity:GetPos()
		-- r(5) = r(0).field(8) // arg0.Camera
		-- r(5) = r(5).field(7) // arg0.Camera.GetPos
		local registerVal5 = arg0.Camera.GetPos()
		-- r(6) = r(0).field(8) // arg0.Camera
		-- r(6) = r(6).field(9) // arg0.Camera.GetOrientation
		arg0:WrangleNetworkZoom(false, registerVal4, registerVal5, arg0.Camera.GetOrientation())
	end
	-- r(1) = g[0] // Network
	-- r(1) = r(1).field(1) // Network.IsInLiveGame
	registerVal1 = Network.IsInLiveGame()
	-- skip the next [10] opcodes // advance 10 lines
	-- r(1) = r(0):c[10] // arg0:IsSpectator
	registerVal1 = arg0:IsSpectator()
	if registerVal1 and registerVal1 then
		-- r(1) = r(0).field(11) // arg0.DelayNextZoomOutUntilNextFrame
		if arg0.DelayNextZoomOutUntilNextFrame == true then
			return 
			-- skip the next [1] opcodes // advance 1 lines
		else
			arg0.DelayNextZoomOutUntilNextFrame = true
		end
	end
	-- r(1) = r(0):c[13] // arg0:GetView
	registerVal1 = arg0:GetView()
	-- r(2) = g[14] // EWorldMapView
	-- r(2) = r(2).field(15) // EWorldMapView.MAP_VIEW_WORLD
	if registerVal1 == EWorldMapView.MAP_VIEW_WORLD then
		-- r(1) = r(0).field(16) // arg0.State
		-- r(2) = g[17] // EWorldMapState
		-- r(2) = r(2).field(18) // EWorldMapState.MAP_STATE_MOVING_FAMILY
		if arg0.State == EWorldMapState.MAP_STATE_MOVING_FAMILY then
			-- r(1) = r(0):c[19] // arg0:AskQuestion
			-- r(3) = c[20] // "TEXT_GUI_SCREEN_MAP_MOVE_FAMILY_CANCEL_QUIT_CONFIRM"
			-- r(4) = c[21] // "QuitMap"
			arg0:AskQuestion("TEXT_GUI_SCREEN_MAP_MOVE_FAMILY_CANCEL_QUIT_CONFIRM", "QuitMap")
			return 
			-- skip the next [10] opcodes // advance 10 lines
		else
			-- r(1) = r(0).field(16) // arg0.State
			-- r(2) = g[17] // EWorldMapState
			-- r(2) = r(2).field(22) // EWorldMapState.MAP_STATE_MOVING_SOLDIERS
			if arg0.State == EWorldMapState.MAP_STATE_MOVING_SOLDIERS then
				-- r(1) = r(0):c[19] // arg0:AskQuestion
				-- r(3) = c[23] // "TEXT_GUI_SCREEN_MAP_MOVE_SOLDIERS_CANCEL_QUIT_CONFIRM"
				-- r(4) = c[21] // "QuitMap"
				arg0:AskQuestion("TEXT_GUI_SCREEN_MAP_MOVE_SOLDIERS_CANCEL_QUIT_CONFIRM", "QuitMap")
				return 
			end
		end
	end
	-- r(1) = r(0).field(24) // arg0.PreviousModes
	if 0.000000 < #arg0.PreviousModes then
		-- r(1) = r(0).field(24) // arg0.PreviousModes
		-- r(2) = r(0).field(24) // arg0.PreviousModes
		-- r(1) = r(1)[r(2)] // arg0.PreviousModes[#arg0.PreviousModes]
		-- r(2) = r(1).field(26) // arg0.PreviousModes[#arg0.PreviousModes].Name
		if arg0.PreviousModes[#arg0.PreviousModes].Name == "WorldView" then
			-- r(2) = g[28] // MessageEvents
			-- r(2) = r(2).field(29) // MessageEvents.PostMessage
			local registerVal3 = {}
			registerVal3.type = "GuiRooms_RoomAboutToChange"
			registerVal3.extra_data = 1.000000
			MessageEvents.PostMessage(registerVal3)
		end
		arg0.ZoomTarget = nil
		-- r(1) = r(0):c[36] // arg0:SetMode
		-- r(3) = g[37] // table
		-- r(3) = r(3).field(38) // table.remove
		-- r(4) = r(0).field(24) // arg0.PreviousModes
		registerVal3 = table.remove(arg0.PreviousModes)
		-- r(4) = c[33] // 1.000000
		arg0:SetMode(registerVal3, 1.000000)
		-- skip the next [14] opcodes // advance 14 lines
	else
		-- r(1) = g[28] // MessageEvents
		-- r(1) = r(1).field(29) // MessageEvents.PostMessage
		local registerVal2 = {}
		registerVal2.type = "GuiRooms_RoomAboutToChange"
		registerVal2.extra_data = 1.000000
		MessageEvents.PostMessage(registerVal2)
		-- r(1) = r(0):c[39] // arg0:ResetFastTravelAbility
		arg0:ResetFastTravelAbility()
		-- r(1) = r(0).field(40) // arg0.Exit
		arg0.Exit()
		-- r(1) = g[41] // SoundTools
		-- r(1) = r(1).field(42) // SoundTools.PlayMainAtmos
		-- r(2) = c[43] // "ATMOS_BATCAVE"
		SoundTools.PlayMainAtmos("ATMOS_BATCAVE")
	end
	-- r(1) = g[45] // CVector3
	-- r(2) = c[25] // 0.000000
	-- r(3) = c[25] // 0.000000
	-- r(4) = c[25] // 0.000000
	registerVal1 = CVector3(0.000000, 0.000000, 0.000000)
	arg0.ControlDirection = registerVal1
	-- r(1) = true
	return true
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x2
	-- Constant Count: 0x2
	-- Registers Count: 0x2
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.ZoomInWhenTargetNextAcquired(arg0)
	arg0.ZoomInOnTarget = true
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0xD
	-- Constant Count: 0x4
	-- Registers Count: 0x8
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x1
function WorldMap.AskQuestion(arg0, arg1, arg2, arg3, arg4)
		-- OP Count: 0x2B
		-- Constant Count: 0x4
		-- Registers Count: 0x6
		-- UpValue Count: 0x5
		-- SubFuncs Count: 0x0
	local function __FUNC_C131_()
		-- r(0) = false
		-- skip the next [12] opcodes // advance 12 lines
		-- skip the next [9] opcodes // advance 9 lines
		-- r(1) = g[0] // GUI
		-- r(1) = r(1).field(1) // GUI.AskYesNoQuestion
		local registerVal1 = GUI.AskYesNoQuestion(, , , )
		-- r(0) = r(1) // registerVal1
		-- skip the next [17] opcodes // advance 17 lines
	else
		if registerVal1 then
			-- r(1) = g[0] // GUI
			-- r(1) = r(1).field(1) // GUI.AskYesNoQuestion
			registerVal1 = GUI.AskYesNoQuestion(, , )
			-- r(0) = r(1) // registerVal1
			-- skip the next [6] opcodes // advance 6 lines
		else
			-- r(1) = g[0] // GUI
			-- r(1) = r(1).field(1) // GUI.AskYesNoQuestion
			registerVal1 = GUI.AskYesNoQuestion(, )
			-- r(0) = r(1) // registerVal1
		end
	end
	if registerVal1 then
		registerVal1[] = true
		-- skip the next [3] opcodes // advance 3 lines
	else
		registerVal1[] = false
	end
	-- return
end

	-- r(0) = r(3) // arg3
	-- r(0) = r(4) // arg4
	-- r(0) = r(1) // arg1
	-- r(0) = r(0) // arg1
	-- r(0) = r(2) // arg2
	arg2[arg2] = nil
	-- r(6) = g[2] // coroutine
	-- r(6) = r(6).field(3) // coroutine.create
	-- r(7) = r(5) // __FUNC_C131_
	local registerVal6 = coroutine.create(__FUNC_C131_)
	arg2.QuestionCoroutine = registerVal6
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0xF
	-- Constant Count: 0x4
	-- Registers Count: 0xA
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x1
function WorldMap.AskQuestionWithTextOverride(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
		-- OP Count: 0x31
		-- Constant Count: 0x4
		-- Registers Count: 0x8
		-- UpValue Count: 0x7
		-- SubFuncs Count: 0x0
	local function __FUNC_C557_()
		-- r(0) = false
		-- skip the next [14] opcodes // advance 14 lines
		-- skip the next [11] opcodes // advance 11 lines
		-- r(1) = g[0] // GUI
		-- r(1) = r(1).field(1) // GUI.AskYesNoQuestionWithTextOverride
		local registerVal1 = GUI.AskYesNoQuestionWithTextOverride(, , , , , )
		-- r(0) = r(1) // registerVal1
		-- skip the next [21] opcodes // advance 21 lines
	else
		if registerVal1 then
			-- r(1) = g[0] // GUI
			-- r(1) = r(1).field(1) // GUI.AskYesNoQuestionWithTextOverride
			registerVal1 = GUI.AskYesNoQuestionWithTextOverride(, , , , )
			-- r(0) = r(1) // registerVal1
			-- skip the next [8] opcodes // advance 8 lines
		else
			-- r(1) = g[0] // GUI
			-- r(1) = r(1).field(1) // GUI.AskYesNoQuestionWithTextOverride
			registerVal1 = GUI.AskYesNoQuestionWithTextOverride(, , , )
			-- r(0) = r(1) // registerVal1
		end
	end
	if registerVal1 then
		registerVal1[] = true
		-- skip the next [3] opcodes // advance 3 lines
	else
		registerVal1[] = false
	end
	-- return
end

	-- r(0) = r(5) // arg5
	-- r(0) = r(6) // arg6
	-- r(0) = r(3) // arg3
	-- r(0) = r(4) // arg4
	-- r(0) = r(1) // arg1
	-- r(0) = r(0) // arg1
	-- r(0) = r(2) // arg2
	arg2[arg2] = nil
	-- r(8) = g[2] // coroutine
	-- r(8) = r(8).field(3) // coroutine.create
	-- r(9) = r(7) // __FUNC_C557_
	local registerVal8 = coroutine.create(__FUNC_C557_)
	arg2.QuestionCoroutine = registerVal8
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x8
	-- Constant Count: 0x4
	-- Registers Count: 0x3
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.TiltCamera(arg0, arg1)
	-- r(2) = r(0).field(0) // arg0.AllowUserControlledCamera
	if arg0.AllowUserControlledCamera then
		-- r(2) = r(0).field(1) // arg0.PitchAdjustment
		arg0.PitchAdjustment = (arg0.PitchAdjustment + arg1)
		arg0.FramesSinceLastMoved = 0.000000
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x19
	-- Constant Count: 0xA
	-- Registers Count: 0x4
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.EnterRulerMode(arg0, arg1)
	-- r(2) = r(0).field(0) // arg0.State
	-- r(3) = g[1] // EWorldMapState
	-- r(3) = r(3).field(2) // EWorldMapState.MAP_STATE_MOVING_FAMILY
	-- skip the next [19] opcodes // advance 19 lines
	-- r(2) = r(0).field(0) // arg0.State
	-- r(3) = g[1] // EWorldMapState
	-- r(3) = r(3).field(3) // EWorldMapState.MAP_STATE_MOVING_SOLDIERS
	if arg0.State ~= EWorldMapState.MAP_STATE_MOVING_FAMILY and arg0.State ~= EWorldMapState.MAP_STATE_MOVING_SOLDIERS then
		-- r(2) = r(0):c[4] // arg0:PauseWorld
		arg0:PauseWorld()
		-- r(2) = g[6] // EWorldMapModes
		-- r(2) = r(2).field(7) // EWorldMapModes.MAP_MODE_RULER_BOARD
		arg0.Mode = EWorldMapModes.MAP_MODE_RULER_BOARD
		if arg1 then
			-- r(2) = g[1] // EWorldMapState
			-- r(2) = r(2).field(8) // EWorldMapState.MAP_STATE_TAX
			arg0.State = EWorldMapState.MAP_STATE_TAX
			-- skip the next [3] opcodes // advance 3 lines
		else
			-- r(2) = g[1] // EWorldMapState
			-- r(2) = r(2).field(9) // EWorldMapState.MAP_STATE_RULER_BOARD
			arg0.State = EWorldMapState.MAP_STATE_RULER_BOARD
		end
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x11
	-- Constant Count: 0xB
	-- Registers Count: 0x3
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.ExitRulerMode(arg0)
	-- r(1) = r(0).field(0) // arg0.CurrentMode
	-- r(2) = r(0).field(1) // arg0.Modes
	-- r(2) = r(2).field(2) // arg0.Modes.StreetView
	if arg0.CurrentMode == arg0.Modes.StreetView then
		-- r(1) = r(0):c[3] // arg0:ZoomOut
		arg0:ZoomOut()
		-- skip the next [8] opcodes // advance 8 lines
	else
		-- r(1) = g[5] // EWorldMapModes
		-- r(1) = r(1).field(6) // EWorldMapModes.MAP_MODE_ZOOM
		arg0.Mode = EWorldMapModes.MAP_MODE_ZOOM
		-- r(1) = g[8] // EWorldMapState
		-- r(1) = r(1).field(9) // EWorldMapState.MAP_STATE_DEFAULT
		arg0.State = EWorldMapState.MAP_STATE_DEFAULT
		-- r(1) = r(0):c[10] // arg0:UnpauseWorld
		arg0:UnpauseWorld()
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x1A
	-- Constant Count: 0xB
	-- Registers Count: 0x3
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.ExitToGame(arg0)
	-- r(1) = r(0):c[0] // arg0:ResetFastTravelAbility
	arg0:ResetFastTravelAbility()
	-- r(1) = g[1] // Network
	-- r(1) = r(1).field(2) // Network.IsInLiveGame
	local registerVal1 = Network.IsInLiveGame()
	-- skip the next [5] opcodes // advance 5 lines
	-- r(1) = g[3] // Guild
	-- r(1) = r(1).field(4) // Guild.IsRemoteHeroInLocalGUI
	registerVal1 = Guild.IsRemoteHeroInLocalGUI()
	if arg0 or registerVal1 then
		-- r(1) = r(0).field(5) // arg0.Exit
		arg0.Exit()
		-- r(1) = g[6] // GUI
		-- r(1) = r(1).field(7) // GUI.SetWorldMapExitDirectlyToGame
		-- r(2) = true
		GUI.SetWorldMapExitDirectlyToGame(true)
		-- skip the next [6] opcodes // advance 6 lines
	else
		-- r(1) = r(0).field(5) // arg0.Exit
		arg0.Exit()
		-- r(1) = g[8] // SoundTools
		-- r(1) = r(1).field(9) // SoundTools.PlayMainAtmos
		-- r(2) = c[10] // "ATMOS_BATCAVE"
		SoundTools.PlayMainAtmos("ATMOS_BATCAVE")
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x9
	-- Constant Count: 0x7
	-- Registers Count: 0x3
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.EnterPartnersList(arg0)
	-- r(1) = r(0):c[0] // arg0:PauseWorld
	arg0:PauseWorld()
	-- r(1) = g[2] // EWorldMapModes
	-- r(1) = r(1).field(3) // EWorldMapModes.MAP_MODE_PARTNERS_GUI
	arg0.Mode = EWorldMapModes.MAP_MODE_PARTNERS_GUI
	-- r(1) = g[5] // EWorldMapState
	-- r(1) = r(1).field(6) // EWorldMapState.MAP_STATE_PARTNERS
	arg0.State = EWorldMapState.MAP_STATE_PARTNERS
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x9
	-- Constant Count: 0x7
	-- Registers Count: 0x3
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.ExitPartnersList(arg0)
	-- r(1) = g[1] // EWorldMapModes
	-- r(1) = r(1).field(2) // EWorldMapModes.MAP_MODE_ZOOM
	arg0.Mode = EWorldMapModes.MAP_MODE_ZOOM
	-- r(1) = g[4] // EWorldMapState
	-- r(1) = r(1).field(5) // EWorldMapState.MAP_STATE_WORLD_VIEW
	arg0.State = EWorldMapState.MAP_STATE_WORLD_VIEW
	-- r(1) = r(0):c[6] // arg0:UnpauseWorld
	arg0:UnpauseWorld()
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x21
	-- Constant Count: 0x8
	-- Registers Count: 0x3
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.ShouldIgnoreAnyInput(arg0)
	-- r(1) = r(0).field(0) // arg0.QuestionCoroutine
	if arg0.QuestionCoroutine then
		-- r(1) = true
		return true
	end
	-- r(1) = r(0).field(1) // arg0.InputIgnoreCountdown
	-- skip the next [5] opcodes // advance 5 lines
	-- r(1) = r(0).field(1) // arg0.InputIgnoreCountdown
	if arg0.InputIgnoreCountdown and 0.000000 < arg0.InputIgnoreCountdown then
		-- r(1) = true
		return true
	end
	-- r(1) = r(0).field(3) // arg0.State
	-- r(2) = g[4] // EWorldMapState
	-- r(2) = r(2).field(5) // EWorldMapState.MAP_STATE_SPECTATOR_MODE
	-- skip the next [5] opcodes // advance 5 lines
	-- r(1) = r(0).field(3) // arg0.State
	-- r(2) = g[4] // EWorldMapState
	-- r(2) = r(2).field(6) // EWorldMapState.MAP_STATE_SPECTATOR_MODE_WEDDING_LOCATION
	if arg0.State == EWorldMapState.MAP_STATE_SPECTATOR_MODE or arg0.State == EWorldMapState.MAP_STATE_SPECTATOR_MODE_WEDDING_LOCATION then
		-- r(1) = true
		return true
	end
	-- r(1) = r(0).field(7) // arg0.IgnoreInput
	if arg0.IgnoreInput then
		-- r(1) = true
		return true
	end
	-- r(1) = false
	return false
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x18
	-- Constant Count: 0x8
	-- Registers Count: 0x3
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.ShouldIgnoreButtonInput(arg0)
	-- r(1) = r(0):c[0] // arg0:ShouldIgnoreAnyInput
	local registerVal1 = arg0:ShouldIgnoreAnyInput()
	if registerVal1 then
		-- r(1) = true
		return true
	end
	-- r(1) = r(0).field(1) // arg0.WaitForCursor
	-- skip the next [12] opcodes // advance 12 lines
	-- r(1) = g[2] // button
	-- r(2) = r(0).field(3) // arg0.PadButtons
	-- r(2) = r(2).field(4) // arg0.PadButtons.B
	-- skip the next [7] opcodes // advance 7 lines
	-- r(1) = r(0).field(5) // arg0.CurrentMode
	-- r(2) = r(0).field(6) // arg0.Modes
	-- r(2) = r(2).field(7) // arg0.Modes.StreetView
	if arg0.WaitForCursor and button ~= arg0.PadButtons.B and arg0.CurrentMode ~= arg0.Modes.StreetView then
		-- r(1) = true
		return true
	end
	-- r(1) = false
	return false
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x11
	-- Constant Count: 0x3
	-- Registers Count: 0x3
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.ShouldIgnoreStickInput(arg0)
	-- r(1) = r(0):c[0] // arg0:ShouldIgnoreAnyInput
	local registerVal1 = arg0:ShouldIgnoreAnyInput()
	if registerVal1 then
		-- r(1) = true
		return true
	end
	-- r(1) = r(0).field(1) // arg0.WaitForCursor
	-- skip the next [3] opcodes // advance 3 lines
	-- r(1) = r(0).field(2) // arg0.MenuOpen
	if not arg0 or arg0.MenuOpen then
		-- r(1) = true
		return true
	end
	-- r(1) = false
	return false
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x1
	-- Constant Count: 0x0
	-- Registers Count: 0x2
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.DoNothing(arg0)
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x17
	-- Constant Count: 0x5
	-- Registers Count: 0x3
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.IsValidZoomTarget(arg0)
	if arg0 == nil then
		-- r(1) = false
		return false
		-- skip the next [15] opcodes // advance 15 lines
	else
		-- r(1) = r(0).field(1) // arg0.Type
		-- r(2) = g[2] // EWorldMapEntityType
		-- r(2) = r(2).field(3) // EWorldMapEntityType.MAP_ENTITY_ORB
		if arg0.Type == EWorldMapEntityType.MAP_ENTITY_ORB then
			-- r(1) = false
			return false
			-- skip the next [7] opcodes // advance 7 lines
		else
			-- r(1) = r(0).field(1) // arg0.Type
			-- r(2) = g[2] // EWorldMapEntityType
			-- r(2) = r(2).field(4) // EWorldMapEntityType.MAP_ENTITY_SOLDIER
			if arg0.Type == EWorldMapEntityType.MAP_ENTITY_SOLDIER then
				-- r(1) = false
				return false
			end
		end
	end
	-- r(1) = true
	return true
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x1D
	-- Constant Count: 0x6
	-- Registers Count: 0x6
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.AnimateCursorGraphic(arg0, arg1, arg2)
	-- r(3) = r(0).field(0) // arg0.CursorGraphic
	-- skip the next [11] opcodes // advance 11 lines
	-- r(3) = r(0).field(1) // arg0.Animate
	-- r(4) = r(0).field(0) // arg0.CursorGraphic
	-- r(5) = r(1) // arg1
	arg0.Animate(arg0.CursorGraphic, arg1)
	if arg0.CursorGraphic and arg2 then
		-- r(3) = r(0).field(0) // arg0.CursorGraphic
		-- r(3) = r(3).field(2) // arg0.CursorGraphic.Entity
		-- r(3) = r(3):c[3] // arg0.CursorGraphic.Entity:RemoveWhenAnimationFinishes
		arg0.CursorGraphic.Entity:RemoveWhenAnimationFinishes()
		arg0.CursorGraphic = nil
	end
	-- r(3) = r(0).field(5) // arg0.CursorGraphicGlass
	-- skip the next [11] opcodes // advance 11 lines
	-- r(3) = r(0).field(1) // arg0.Animate
	-- r(4) = r(0).field(5) // arg0.CursorGraphicGlass
	-- r(5) = r(1) // arg1
	arg0.Animate(arg0.CursorGraphicGlass, arg1)
	if arg0.CursorGraphicGlass and arg2 then
		-- r(3) = r(0).field(5) // arg0.CursorGraphicGlass
		-- r(3) = r(3).field(2) // arg0.CursorGraphicGlass.Entity
		-- r(3) = r(3):c[3] // arg0.CursorGraphicGlass.Entity:RemoveWhenAnimationFinishes
		arg0.CursorGraphicGlass.Entity:RemoveWhenAnimationFinishes()
		arg0.CursorGraphicGlass = nil
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x20
	-- Constant Count: 0xF
	-- Registers Count: 0xA
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.SetCursorAndCameraPosition(arg0, arg1, arg2, arg3, arg4)
	if not arg4 then
		-- r(5) = r(0).field(0) // arg0.Cursor
		-- r(5) = r(5).field(1) // arg0.Cursor.Entity
		-- r(5) = r(5):c[2] // arg0.Cursor.Entity:GetPos
		local registerVal5 = arg0.Cursor.Entity:GetPos()
		-- r(5) = r(5):c[3] // (registerVal5 - arg1):GetLengthXY
		registerVal5 = (registerVal5 - arg1):GetLengthXY()
		-- skip the next [20] opcodes // advance 20 lines
		-- r(5) = r(0).field(5) // arg0.ZoomInOnTarget
		-- skip the next [17] opcodes // advance 17 lines
		-- r(5) = r(0):c[7] // arg0:AnyMoreZoomPackets
		registerVal5 = arg0:AnyMoreZoomPackets()
		if 0.100000 < registerVal5 and arg0.ZoomInOnTarget == nil and registerVal5 == false then
			-- r(5) = r(0).field(9) // arg0.Animate
			-- r(6) = r(0).field(0) // arg0.Cursor
			local registerVal7 = {}
			local registerVal8 = {}
			local registerVal9 = {}
			registerVal9.Position = arg1
			registerVal8[0.300000] = registerVal9
			registerVal7.Keyframes = registerVal8
			arg0.Animate(arg0.Cursor, registerVal7)
			-- r(5) = r(0):c[13] // arg0:FocusOn
			-- r(7) = r(1) // arg1
			-- r(8) = c[14] // 0.600000
			arg0:FocusOn(arg1, 0.600000)
		end
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x1C
	-- Constant Count: 0x8
	-- Registers Count: 0xB
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.SetCursorAndCameraPositionForZoom(arg0, arg1, arg2, arg3, arg4)
	-- r(5) = r(0).field(0) // arg0.ZoomInOnTarget
	-- skip the next [18] opcodes // advance 18 lines
	-- r(5) = r(0):c[2] // arg0:AnyMoreZoomPackets
	local registerVal5 = arg0:AnyMoreZoomPackets()
	if arg0.ZoomInOnTarget == nil and registerVal5 == false then
		-- r(5) = r(0):c[4] // arg0:SetCursorAndCameraPosition
		-- r(7) = r(1) // arg1
		-- r(8) = r(2) // arg2
		-- r(9) = r(3) // arg3
		-- r(10) = true
		arg0:SetCursorAndCameraPosition(arg1, arg2, arg3, true)
		if arg4 then
			-- r(5) = r(0):c[5] // arg0:ZoomInWhenTargetNextAcquired
			arg0:ZoomInWhenTargetNextAcquired()
			-- skip the next [9] opcodes // advance 9 lines
		else
			-- r(5) = r(0):c[6] // arg0:ZoomOut
			arg0:ZoomOut()
			-- skip the next [6] opcodes // advance 6 lines
		else
			-- r(5) = r(0):c[7] // arg0:WrangleNetworkZoom
			-- r(7) = r(4) // arg4
			-- r(8) = r(1) // arg1
			-- r(9) = r(2) // arg2
			-- r(10) = r(3) // arg3
			arg0:WrangleNetworkZoom(arg4, arg1, arg2, arg3)
		end
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x2
	-- Constant Count: 0x1
	-- Registers Count: 0x2
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.SetIgnoreWorldMapInput(arg0, arg1)
	arg0.IgnoreInput = arg1
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x16
	-- Constant Count: 0x4
	-- Registers Count: 0x3
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.ShouldTeleportToLevelFromRegionView(arg0, arg1)
	-- skip the next [17] opcodes // advance 17 lines
	-- r(2) = g[0] // Gameflow
	-- r(2) = r(2).field(1) // Gameflow.AvailableRegions
	-- skip the next [13] opcodes // advance 13 lines
	-- r(2) = g[0] // Gameflow
	-- r(2) = r(2).field(1) // Gameflow.AvailableRegions
	-- r(2) = r(2)[r(1)] // Gameflow.AvailableRegions[arg1]
	-- skip the next [8] opcodes // advance 8 lines
	-- r(2) = g[0] // Gameflow
	-- r(2) = r(2).field(1) // Gameflow.AvailableRegions
	-- r(2) = r(2)[r(1)] // Gameflow.AvailableRegions[arg1]
	-- r(2) = r(2).field(2) // Gameflow.AvailableRegions[arg1].TeleportOnWorldMapAccess
	if arg1 and Gameflow.AvailableRegions and Gameflow.AvailableRegions[arg1] and Gameflow.AvailableRegions[arg1].TeleportOnWorldMapAccess == true then
		-- r(2) = true
		return true
	end
	-- r(2) = false
	return false
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x22
	-- Constant Count: 0x8
	-- Registers Count: 0x7
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.CanZoomIntoLevel(arg0, arg1)
	-- r(2) = g[0] // string
	-- r(2) = r(2).field(1) // string.lower
	-- r(3) = r(1).field(2) // arg1.GameLevel
	local registerVal2 = string.lower(arg1.GameLevel)
	-- r(3) = r(1).field(3) // arg1.Name
	-- r(4) = r(0):c[4] // arg0:IsRegionInDarkness
	-- r(6) = r(2) // registerVal2
	local registerVal4 = arg0:IsRegionInDarkness(registerVal2)
	if registerVal4 then
		-- r(4) = false
		return false
		-- skip the next [18] opcodes // advance 18 lines
	else
		-- r(4) = r(0).field(5) // arg0.AddAllRegions
		-- skip the next [5] opcodes // advance 5 lines
		-- r(4) = r(0).field(6) // arg0.IsLevelUnlocked
		-- r(5) = r(3) // arg1.Name
		registerVal4 = arg0.IsLevelUnlocked(arg1.Name)
		if not arg1 or registerVal4 then
			-- r(4) = true
			return true
			-- skip the next [7] opcodes // advance 7 lines
		else
			-- r(4) = r(0):c[7] // arg0:IsRegionAvailable
			-- r(6) = r(1) // arg1
			registerVal4 = arg0:IsRegionAvailable(arg1)
			if registerVal4 then
				-- r(4) = true
				return true
			end
		end
	end
	-- r(4) = false
	return false
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x15
	-- Constant Count: 0x4
	-- Registers Count: 0x3
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.IsRegionInDarkness(arg0, arg1)
	-- r(2) = g[0] // Gameflow
	-- r(2) = r(2).field(1) // Gameflow.AvailableRegions
	-- skip the next [14] opcodes // advance 14 lines
	-- r(2) = g[0] // Gameflow
	-- r(2) = r(2).field(1) // Gameflow.AvailableRegions
	-- r(2) = r(2)[r(1)] // Gameflow.AvailableRegions[arg1]
	if Gameflow.AvailableRegions and Gameflow.AvailableRegions[arg1] then
		-- r(2) = g[0] // Gameflow
		-- r(2) = r(2).field(1) // Gameflow.AvailableRegions
		-- r(2) = r(2)[r(1)] // Gameflow.AvailableRegions[arg1]
		-- r(2) = r(2).field(2) // Gameflow.AvailableRegions[arg1].Darkness
		if Gameflow.AvailableRegions[arg1].Darkness ~= true then
			-- r(2) = false // skip next opcode
		end
		-- r(2) = true
		return true
	end
	-- r(2) = false
	return false
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x19
	-- Constant Count: 0x6
	-- Registers Count: 0x5
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.IsTargetRegionInDarkness(arg0)
	-- r(1) = r(0).field(0) // arg0.Target
	-- skip the next [19] opcodes // advance 19 lines
	-- r(1) = r(0).field(0) // arg0.Target
	-- r(1) = r(1).field(1) // arg0.Target.RegionInfo
	-- skip the next [15] opcodes // advance 15 lines
	-- r(1) = r(0).field(0) // arg0.Target
	-- r(1) = r(1).field(1) // arg0.Target.RegionInfo
	-- r(1) = r(1).field(2) // arg0.Target.RegionInfo.GameLevel
	if arg0.Target and arg0.Target.RegionInfo and arg0.Target.RegionInfo.GameLevel then
		-- r(1) = g[3] // string
		-- r(1) = r(1).field(4) // string.lower
		-- r(2) = r(0).field(0) // arg0.Target
		-- r(2) = r(2).field(1) // arg0.Target.RegionInfo
		-- r(2) = r(2).field(2) // arg0.Target.RegionInfo.GameLevel
		local registerVal1 = string.lower(arg0.Target.RegionInfo.GameLevel)
		-- r(2) = r(0):c[5] // arg0:IsRegionInDarkness
		-- r(4) = r(1) // registerVal1
		return arg0:IsRegionInDarkness(registerVal1)
		-- return
	end
	-- r(1) = false
	return false
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x1C
	-- Constant Count: 0xB
	-- Registers Count: 0xB
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.MoveCursorToTarget(arg0, arg1, arg2)
	-- r(3) = r(0):c[0] // arg0:GetTarget
	-- r(5) = r(1) // arg1
	local registerVal3 = arg0:GetTarget(arg1)
	-- skip the next [22] opcodes // advance 22 lines
	-- r(4) = r(3).field(2) // registerVal3.Entity
	if registerVal3 ~= nil and registerVal3.Entity ~= nil then
		if not arg2 then
			-- r(2) = c[3] // 0.000000
		end
		-- r(4) = r(0).field(4) // arg0.Animate
		-- r(5) = r(0).field(5) // arg0.Cursor
		local registerVal6 = {}
		local registerVal7 = {}
		local registerVal8 = {}
		-- r(9) = r(3).field(2) // registerVal3.Entity
		-- r(9) = r(9):c[8] // registerVal3.Entity:GetFinalPos
		local registerVal9 = registerVal3.Entity:GetFinalPos()
		registerVal8.Position = registerVal9
		registerVal7[0.000000] = registerVal8
		registerVal6.Keyframes = registerVal7
		arg0.Animate(arg0.Cursor, registerVal6)
		-- r(4) = r(3).field(2) // registerVal3.Entity
		-- r(4) = r(4):c[10] // registerVal3.Entity:GetPos
		local registerVal4 = registerVal3.Entity:GetPos()
		arg0.FocusPosition = registerVal4
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0xD
	-- Constant Count: 0x3
	-- Registers Count: 0x8
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.GetTarget(arg0, arg1)
	-- r(2) = g[0] // pairs
	-- r(3) = r(0).field(1) // arg0.PotentialTargets
	local registerVal2, registerVal3, registerVal4 = pairs(arg0.PotentialTargets)
	for index5,value6 in registerVal2, registerVal3, registerVal4 do
		-- skip the next [4] opcodes // advance 4 lines
		-- r(7) = r(6).field(2) // value6.Name
		if value6.Name == arg1 then
			return value6
		end
		-- skip the next [-6] opcodes // advance -6 lines
	end
	-- r(2) = nil
	return nil
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x41
	-- Constant Count: 0xE
	-- Registers Count: 0xC
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.WrangleNetworkZoom(arg0, arg1, arg2, arg3, arg4)
	-- r(5) = r(0).field(0) // arg0.ZoomPackets
	-- skip the next [6] opcodes // advance 6 lines
	-- r(5) = g[2] // table
	-- r(5) = r(5).field(3) // table.getn
	-- r(6) = r(0).field(0) // arg0.ZoomPackets
	local registerVal5 = table.getn(arg0.ZoomPackets)
	if arg0.ZoomPackets == nil or registerVal5 == 0.000000 then
		-- r(5) = r(0).field(5) // arg0.SelectionModeMultiplayer
		-- skip the next [16] opcodes // advance 16 lines
		-- r(5) = g[7] // Network
		-- r(5) = r(5).field(8) // Network.IsInLiveGame
		registerVal5 = Network.IsInLiveGame()
		-- skip the next [11] opcodes // advance 11 lines
		-- r(5) = r(0):c[9] // arg0:IsActor
		registerVal5 = arg0:IsActor()
		if arg0.SelectionModeMultiplayer == true and registerVal5 and registerVal5 then
			-- r(5) = r(0).field(10) // arg0.SendZoomPacket
			-- r(6) = r(1) // arg1
			-- r(7) = r(2) // arg2
			-- r(8) = r(3) // arg3
			-- r(9) = r(4) // arg4
			arg0.SendZoomPacket(arg1, arg2, arg3, arg4)
			-- skip the next [36] opcodes // advance 36 lines
		else
		else
			-- skip the next [4] opcodes // advance 4 lines
			-- r(5) = r(0):c[9] // arg0:IsActor
			registerVal5 = arg0:IsActor()
			if not arg0 or registerVal5 == false then
				-- r(5) = r(0).field(0) // arg0.ZoomPackets
				if arg0.ZoomPackets == nil then
					arg0.ZoomPackets = {}
				end
				-- r(5) = r(0).field(0) // arg0.ZoomPackets
				-- r(6) = g[2] // table
				-- r(6) = r(6).field(3) // table.getn
				-- r(7) = r(0).field(0) // arg0.ZoomPackets
				local registerVal6 = table.getn(arg0.ZoomPackets)
				local registerVal7 = {}
				-- r(8) = r(1) // arg1
				-- r(9) = r(2) // arg2
				-- r(10) = r(3) // arg3
				-- r(11) = r(4) // arg4
				registerVal7 = {arg1, arg2, arg3, arg4}
				arg0.ZoomPackets[(registerVal6 + 1.000000)] = registerVal7
				-- skip the next [11] opcodes // advance 11 lines
			else
				-- r(5) = r(0).field(0) // arg0.ZoomPackets
				if arg0.ZoomPackets ~= nil then
					-- r(5) = g[2] // table
					-- r(5) = r(5).field(13) // table.remove
					-- r(6) = r(0).field(0) // arg0.ZoomPackets
					-- r(7) = g[2] // table
					-- r(7) = r(7).field(3) // table.getn
					-- r(8) = r(0).field(0) // arg0.ZoomPackets
					table.remove(arg0.ZoomPackets, table.getn(arg0.ZoomPackets))
				end
			end
		end
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x26
	-- Constant Count: 0xF
	-- Registers Count: 0xC
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.WrangleNextZoomPacket(arg0)
	-- r(1) = r(0):c[0] // arg0:AnyMoreZoomPackets
	local registerVal1 = arg0:AnyMoreZoomPackets()
	-- skip the next [33] opcodes // advance 33 lines
	-- r(1) = g[1] // ipairs
	-- r(2) = r(0).field(2) // arg0.ZoomPackets
	registerVal1, registerVal2, registerVal3 = ipairs(arg0.ZoomPackets)
	for index4,value5 in registerVal1, registerVal2, registerVal3 do
		-- skip the next [27] opcodes // advance 27 lines
		-- r(6) = r(0):c[3] // arg0:SetCursorAndCameraPosition
		-- r(8) = r(5)[c[4]] // value5[2.000000]
		-- r(9) = r(5)[c[5]] // value5[3.000000]
		-- r(10) = r(5)[c[6]] // value5[4.000000]
		-- r(11) = true
		arg0:SetCursorAndCameraPosition(value5[2.000000], value5[3.000000], value5[4.000000], true)
		-- r(6) = r(5)[c[7]] // value5[1.000000]
		if value5[1.000000] then
			-- r(6) = r(0):c[8] // arg0:ZoomInWhenTargetNextAcquired
			arg0:ZoomInWhenTargetNextAcquired()
			-- skip the next [2] opcodes // advance 2 lines
		else
			-- r(6) = r(0):c[9] // arg0:ZoomOut
			arg0:ZoomOut()
		end
		-- r(6) = g[10] // table
		-- r(6) = r(6).field(11) // table.remove
		-- r(7) = r(0).field(2) // arg0.ZoomPackets
		-- r(8) = r(4) // index4
		table.remove(arg0.ZoomPackets, index4)
		-- r(6) = g[10] // table
		-- r(6) = r(6).field(12) // table.getn
		-- r(7) = r(0).field(2) // arg0.ZoomPackets
		local registerVal6 = table.getn(arg0.ZoomPackets)
		if registerVal6 == 0.000000 then
			arg0.ZoomPackets = nil
		end
		return 
		-- skip the next [-29] opcodes // advance -29 lines
	end
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0xD
	-- Constant Count: 0x5
	-- Registers Count: 0x3
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.AnyMoreZoomPackets(arg0)
	-- r(1) = r(0).field(0) // arg0.ZoomPackets
	-- skip the next [6] opcodes // advance 6 lines
	-- r(1) = g[2] // table
	-- r(1) = r(1).field(3) // table.getn
	-- r(2) = r(0).field(0) // arg0.ZoomPackets
	local registerVal1 = table.getn(arg0.ZoomPackets)
	if arg0.ZoomPackets == nil or 0.000000 >= registerVal1 then
		-- r(1) = false // skip next opcode
	end
	-- r(1) = true
	return true
	-- return
end

-- r(1) = g[16] // WorldMap
	-- OP Count: 0x10
	-- Constant Count: 0x5
	-- Registers Count: 0x3
	-- UpValue Count: 0x0
	-- SubFuncs Count: 0x0
function WorldMap.CanJoinGameViaOrb(arg0)
	-- r(1) = r(0).field(0) // arg0.SelectionModeType
	-- r(2) = g[1] // WorldMap
	-- r(2) = r(2).field(2) // WorldMap.SelectionModeTypeEnum
	-- r(2) = r(2).field(3) // WorldMap.SelectionModeTypeEnum.ADOPTION
	-- skip the next [6] opcodes // advance 6 lines
	-- r(1) = r(0).field(0) // arg0.SelectionModeType
	-- r(2) = g[1] // WorldMap
	-- r(2) = r(2).field(2) // WorldMap.SelectionModeTypeEnum
	-- r(2) = r(2).field(4) // WorldMap.SelectionModeTypeEnum.MARRIAGE
	if arg0.SelectionModeType == WorldMap.SelectionModeTypeEnum.ADOPTION or arg0.SelectionModeType == WorldMap.SelectionModeTypeEnum.MARRIAGE then
		-- r(1) = false // skip next opcode
	end
	-- r(1) = true
	return true
	-- return
end

-- return
